{"/home/travis/build/npmtest/node-npmtest-esdoc/test.js":"/* istanbul instrument in package npmtest_esdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-esdoc/lib.npmtest_esdoc.js":"/* istanbul instrument in package npmtest_esdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_esdoc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_esdoc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-esdoc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-esdoc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_esdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_esdoc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_esdoc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_esdoc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_esdoc.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_esdoc.__dirname + '/lib.npmtest_esdoc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/ESDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _assert = require('assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _colorLogger = require('color-logger');\n\nvar _colorLogger2 = _interopRequireDefault(_colorLogger);\n\nvar _ASTUtil = require('./Util/ASTUtil.js');\n\nvar _ASTUtil2 = _interopRequireDefault(_ASTUtil);\n\nvar _ESParser = require('./Parser/ESParser');\n\nvar _ESParser2 = _interopRequireDefault(_ESParser);\n\nvar _PathResolver = require('./Util/PathResolver.js');\n\nvar _PathResolver2 = _interopRequireDefault(_PathResolver);\n\nvar _DocFactory = require('./Factory/DocFactory.js');\n\nvar _DocFactory2 = _interopRequireDefault(_DocFactory);\n\nvar _TestDocFactory = require('./Factory/TestDocFactory.js');\n\nvar _TestDocFactory2 = _interopRequireDefault(_TestDocFactory);\n\nvar _InvalidCodeLogger = require('./Util/InvalidCodeLogger.js');\n\nvar _InvalidCodeLogger2 = _interopRequireDefault(_InvalidCodeLogger);\n\nvar _Plugin = require('./Plugin/Plugin.js');\n\nvar _Plugin2 = _interopRequireDefault(_Plugin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst logger = new _colorLogger2.default('ESDoc');\n\n/**\n * API Documentation Generator.\n *\n * @example\n * let config = {source: './src', destination: './esdoc'};\n * ESDoc.generate(config, (results, config)=>{\n *   console.log(results);\n * });\n */\nclass ESDoc {\n  /**\n   * Generate documentation.\n   * @param {ESDocConfig} config - config for generation.\n   * @param {function(results: Object[], asts: Object[], config: ESDocConfig)} publisher - callback for output html.\n   */\n  static generate(config, publisher) {\n    (0, _assert2.default)(typeof publisher === 'function');\n    (0, _assert2.default)(config.source);\n    (0, _assert2.default)(config.destination);\n\n    _Plugin2.default.init(config.plugins);\n    _Plugin2.default.onStart();\n    config = _Plugin2.default.onHandleConfig(config);\n\n    this._setDefaultConfig(config);\n    this._deprecatedConfig(config);\n\n    _colorLogger2.default.debug = !!config.debug;\n    const includes = config.includes.map(v => new RegExp(v));\n    const excludes = config.excludes.map(v => new RegExp(v));\n\n    let packageName = null;\n    let mainFilePath = null;\n    if (config.package) {\n      try {\n        const packageJSON = _fs2.default.readFileSync(config.package, { encode: 'utf8' });\n        const packageConfig = JSON.parse(packageJSON);\n        packageName = packageConfig.name;\n        mainFilePath = packageConfig.main;\n      } catch (e) {\n        // ignore\n      }\n    }\n\n    let results = [];\n    const asts = [];\n    const sourceDirPath = _path2.default.resolve(config.source);\n\n    this._walk(config.source, filePath => {\n      const relativeFilePath = _path2.default.relative(sourceDirPath, filePath);\n      let match = false;\n      for (const reg of includes) {\n        if (relativeFilePath.match(reg)) {\n          match = true;\n          break;\n        }\n      }\n      if (!match) return;\n\n      for (const reg of excludes) {\n        if (relativeFilePath.match(reg)) return;\n      }\n\n      console.log(`parse: ${ filePath }`);\n      const temp = this._traverse(config, config.source, filePath, packageName, mainFilePath);\n      if (!temp) return;\n      results.push(...temp.results);\n\n      asts.push({ filePath: `source${ _path2.default.sep }${ relativeFilePath }`, ast: temp.ast });\n    });\n\n    if (config.builtinExternal) {\n      this._useBuiltinExternal(config, results);\n    }\n\n    if (config.test) {\n      this._generateForTest(config, results, asts);\n    }\n\n    results = _Plugin2.default.onHandleTag(results);\n\n    try {\n      publisher(results, asts, config);\n    } catch (e) {\n      _InvalidCodeLogger2.default.showError(e);\n      process.exit(1);\n    }\n\n    _Plugin2.default.onComplete();\n  }\n\n  /**\n   * Generate document from test code.\n   * @param {ESDocConfig} config - config for generating.\n   * @param {DocObject[]} results - push DocObject to this.\n   * @param {AST[]} asts - push ast to this.\n   * @private\n   */\n  static _generateForTest(config, results, asts) {\n    const includes = config.test.includes.map(v => new RegExp(v));\n    const excludes = config.test.excludes.map(v => new RegExp(v));\n    const sourceDirPath = _path2.default.resolve(config.test.source);\n\n    this._walk(config.test.source, filePath => {\n      const relativeFilePath = _path2.default.relative(sourceDirPath, filePath);\n      let match = false;\n      for (const reg of includes) {\n        if (relativeFilePath.match(reg)) {\n          match = true;\n          break;\n        }\n      }\n      if (!match) return;\n\n      for (const reg of excludes) {\n        if (relativeFilePath.match(reg)) return;\n      }\n\n      console.log(`parse: ${ filePath }`);\n      const temp = this._traverseForTest(config, config.test.type, config.test.source, filePath);\n      if (!temp) return;\n      results.push(...temp.results);\n\n      asts.push({ filePath: `test${ _path2.default.sep }${ relativeFilePath }`, ast: temp.ast });\n    });\n  }\n\n  /**\n   * set default config to specified config.\n   * @param {ESDocConfig} config - specified config.\n   * @private\n   */\n  static _setDefaultConfig(config) {\n    if (!config.includes) config.includes = ['\\\\.(js|es6)$'];\n\n    if (!config.excludes) config.excludes = ['\\\\.config\\\\.(js|es6)$'];\n\n    if (!config.access) config.access = ['public', 'protected'];\n\n    if (!('autoPrivate' in config)) config.autoPrivate = true;\n\n    if (!('unexportIdentifier' in config)) config.unexportIdentifier = false;\n\n    if (!('builtinExternal' in config)) config.builtinExternal = true;\n\n    if (!('undocumentIdentifier' in config)) config.undocumentIdentifier = true;\n\n    if (!('coverage' in config)) config.coverage = true;\n\n    if (!('includeSource' in config)) config.includeSource = true;\n\n    if (!('lint' in config)) config.lint = true;\n\n    if (!config.index) config.index = './README.md';\n\n    if (!config.package) config.package = './package.json';\n\n    if (!config.styles) config.styles = [];\n\n    if (!config.scripts) config.scripts = [];\n\n    if (config.test) {\n      (0, _assert2.default)(config.test.type);\n      (0, _assert2.default)(config.test.source);\n      if (!config.test.includes) config.test.includes = ['(spec|Spec|test|Test)\\\\.(js|es6)$'];\n      if (!config.test.excludes) config.test.excludes = ['\\\\.config\\\\.(js|es6)$'];\n    }\n\n    if (config.manual) {\n      if (!('coverage' in config.manual)) config.manual.coverage = true;\n    }\n  }\n\n  /* eslint-disable no-unused-vars */\n  static _deprecatedConfig(config) {}\n  // do nothing\n\n\n  /**\n   * Use built-in external document.\n   * built-in external has number, string, boolean, etc...\n   * @param {ESDocConfig} config - config of esdoc.\n   * @param {DocObject[]} results - this method pushes DocObject to this param.\n   * @private\n   * @see {@link src/BuiltinExternal/ECMAScriptExternal.js}\n   */\n  static _useBuiltinExternal(config, results) {\n    const dirPath = _path2.default.resolve(__dirname, './BuiltinExternal/');\n    this._walk(dirPath, filePath => {\n      const temp = this._traverse(config, dirPath, filePath);\n      /* eslint-disable no-return-assign */\n      temp.results.forEach(v => v.builtinExternal = true);\n      const res = temp.results.filter(v => v.kind === 'external');\n      results.push(...res);\n    });\n  }\n\n  /**\n   * walk recursive in directory.\n   * @param {string} dirPath - target directory path.\n   * @param {function(entryPath: string)} callback - callback for find file.\n   * @private\n   */\n  static _walk(dirPath, callback) {\n    const entries = _fs2.default.readdirSync(dirPath);\n\n    for (const entry of entries) {\n      const entryPath = _path2.default.resolve(dirPath, entry);\n      const stat = _fs2.default.statSync(entryPath);\n\n      if (stat.isFile()) {\n        callback(entryPath);\n      } else if (stat.isDirectory()) {\n        this._walk(entryPath, callback);\n      }\n    }\n  }\n\n  /**\n   * traverse doc comment in JavaScript file.\n   * @param {ESDocConfig} config - config of esdoc.\n   * @param {string} inDirPath - root directory path.\n   * @param {string} filePath - target JavaScript file path.\n   * @param {string} [packageName] - npm package name of target.\n   * @param {string} [mainFilePath] - npm main file path of target.\n   * @returns {Object} - return document that is traversed.\n   * @property {DocObject[]} results - this is contained JavaScript file.\n   * @property {AST} ast - this is AST of JavaScript file.\n   * @private\n   */\n  static _traverse(config, inDirPath, filePath, packageName, mainFilePath) {\n    logger.i(`parsing: ${ filePath }`);\n    let ast;\n    try {\n      ast = _ESParser2.default.parse(config, filePath);\n    } catch (e) {\n      _InvalidCodeLogger2.default.showFile(filePath, e);\n      return null;\n    }\n\n    const pathResolver = new _PathResolver2.default(inDirPath, filePath, packageName, mainFilePath);\n    const factory = new _DocFactory2.default(ast, pathResolver);\n\n    _ASTUtil2.default.traverse(ast, (node, parent) => {\n      try {\n        factory.push(node, parent);\n      } catch (e) {\n        _InvalidCodeLogger2.default.show(filePath, node);\n        throw e;\n      }\n    });\n\n    return { results: factory.results, ast: ast };\n  }\n\n  /**\n   * traverse doc comment in test code file.\n   * @param {ESDocConfig} config - config of esdoc.\n   * @param {string} type - test code type.\n   * @param {string} inDirPath - root directory path.\n   * @param {string} filePath - target test code file path.\n   * @returns {Object} return document info that is traversed.\n   * @property {DocObject[]} results - this is contained test code.\n   * @property {AST} ast - this is AST of test code.\n   * @private\n   */\n  static _traverseForTest(config, type, inDirPath, filePath) {\n    let ast;\n    try {\n      ast = _ESParser2.default.parse(config, filePath);\n    } catch (e) {\n      _InvalidCodeLogger2.default.showFile(filePath, e);\n      return null;\n    }\n    const pathResolver = new _PathResolver2.default(inDirPath, filePath);\n    const factory = new _TestDocFactory2.default(type, ast, pathResolver);\n\n    _ASTUtil2.default.traverse(ast, (node, parent) => {\n      try {\n        factory.push(node, parent);\n      } catch (e) {\n        _InvalidCodeLogger2.default.show(filePath, node);\n        throw e;\n      }\n    });\n\n    return { results: factory.results, ast: ast };\n  }\n}\nexports.default = ESDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Util/ASTUtil.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _babelTraverse = require('babel-traverse');\n\nvar _babelTraverse2 = _interopRequireDefault(_babelTraverse);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Utility for AST.\n */\nclass ASTUtil {\n  /**\n   * sanitize node.\n   * change node type to `Identifier` and empty comment.\n   * @param {ASTNode} node - target node.\n   */\n  static sanitize(node) {\n    if (!node) return;\n    node.type = 'Identifier';\n    node.name = '_';\n    node.leadingComments = [];\n    node.trailingComments = [];\n  }\n\n  /**\n   * traverse ast nodes.\n   * @param {AST} ast - target AST.\n   * @param {function(node: Object, parent: Object, path: Object)} callback - this is called with each node.\n   */\n  static traverse(ast, callback) {\n    (0, _babelTraverse2.default)(ast, {\n      noScope: true,\n      enter: function (path) {\n        callback(path.node, path.parent, path);\n      }\n    });\n  }\n\n  /**\n   * find file path in import declaration by name.\n   * e.g. can find ``./foo/bar.js`` from ``import Bar from './foo/bar.js'`` by ``Bar``.\n   * @param {AST} ast - target AST.\n   * @param {string} name - identifier name.\n   * @returns {string|null} file path.\n   */\n  static findPathInImportDeclaration(ast, name) {\n    let path = null;\n\n    (0, _babelTraverse2.default)(ast, {\n      noScope: true,\n      enter: function (_path) {\n        const node = _path.node;\n        if (node.type !== 'ImportDeclaration') return;\n\n        for (const spec of node.specifiers) {\n          const localName = spec.local.name;\n          if (localName === name) {\n            path = node.source.value;\n            _path.stop();\n          }\n        }\n      }\n    });\n\n    return path;\n  }\n\n  /**\n   * find VariableDeclaration node which has NewExpression.\n   * @param {string} name - variable name.\n   * @param {AST} ast - find in this ast.\n   * @returns {ASTNode|null} found ast node.\n   */\n  static findVariableDeclarationAndNewExpressionNode(name, ast) {\n    if (!name) return null;\n\n    for (const node of ast.program.body) {\n      if (node.type === 'VariableDeclaration' && node.declarations[0].init && node.declarations[0].init.type === 'NewExpression' && node.declarations[0].id.name === name) {\n        return node;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * find ClassDeclaration node.\n   * @param {string} name - class name.\n   * @param {AST} ast - find in this ast.\n   * @returns {ASTNode|null} found ast node.\n   */\n  static findClassDeclarationNode(name, ast) {\n    if (!name) return null;\n\n    for (const node of ast.program.body) {\n      if (node.type === 'ClassDeclaration' && node.id.name === name) return node;\n    }\n\n    return null;\n  }\n\n  /**\n   * find FunctionDeclaration node.\n   * @param {string} name - function name.\n   * @param {AST} ast - find in this ast.\n   * @returns {ASTNode|null} found ast node.\n   */\n  static findFunctionDeclarationNode(name, ast) {\n    if (!name) return null;\n\n    for (const node of ast.program.body) {\n      if (node.type === 'FunctionDeclaration' && node.id.name === name) return node;\n    }\n\n    return null;\n  }\n\n  /**\n   * find VariableDeclaration node.\n   * @param {string} name - variable name.\n   * @param {AST} ast - find in this ast.\n   * @returns {ASTNode|null} found ast node.\n   */\n  static findVariableDeclarationNode(name, ast) {\n    if (!name) return null;\n\n    for (const node of ast.program.body) {\n      if (node.type === 'VariableDeclaration' && node.declarations[0].id.name === name) return node;\n    }\n\n    return null;\n  }\n\n  /**\n   * create VariableDeclaration node which has NewExpression.\n   * @param {string} name - variable name.\n   * @param {string} className - class name.\n   * @param {Object} loc - location.\n   * @returns {ASTNode} created node.\n   */\n  static createVariableDeclarationAndNewExpressionNode(name, className, loc) {\n    const node = {\n      type: 'VariableDeclaration',\n      kind: 'let',\n      loc: loc,\n      declarations: [{\n        type: 'VariableDeclarator',\n        id: { type: 'Identifier', name: name },\n        init: { type: 'NewExpression', callee: { type: 'Identifier', name: className } }\n      }]\n    };\n\n    return node;\n  }\n\n  // /**\n  //  * flatten name of MemberExpression.\n  //  * @param {ASTNode} memberExpression - MemberExpression Node.\n  //  * @returns {string} flatten node name.\n  //  */\n  // static flattenMemberExpression(memberExpression) {\n  //   const names = [];\n  //   let object = memberExpression;\n  //   while (object) {\n  //     if (object.name) {\n  //       names.push(object.name);\n  //       break;\n  //     } else {\n  //       names.push(object.property.name);\n  //       object = object.object;\n  //     }\n  //   }\n  //   return names.reverse().join('.');\n  // }\n}\nexports.default = ASTUtil;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Parser/ESParser.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fsExtra = require('fs-extra');\n\nvar _fsExtra2 = _interopRequireDefault(_fsExtra);\n\nvar _Plugin = require('../Plugin/Plugin.js');\n\nvar _Plugin2 = _interopRequireDefault(_Plugin);\n\nvar _babylon = require('babylon');\n\nvar babylon = _interopRequireWildcard(_babylon);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * ECMAScript Parser class.\n *\n * @example\n * let ast = ESParser.parse('./src/foo.js');\n */\nclass ESParser {\n  /**\n   * parse ECMAScript source code.\n   * @param {ESDocConfig} config - config of esdoc.\n   * @param {string} filePath - source code file path.\n   * @returns {AST} AST of source code.\n   */\n  static parse(config, filePath) {\n    return this._parseWithBabylon(config, filePath);\n  }\n\n  /**\n   * parse ECMAScript source code with babylon.\n   * @param {ESDocConfig} config - config of esdoc.\n   * @param {string} filePath - source code file path.\n   * @returns {AST} AST of source code.\n   */\n  static _parseWithBabylon(config, filePath) {\n    let code = _fsExtra2.default.readFileSync(filePath, { encode: 'utf8' }).toString();\n    code = _Plugin2.default.onHandleCode(code, filePath);\n    if (code.charAt(0) === '#') code = code.replace(/^#!/, '//');\n\n    const option = this._buildParserOptionForBabylon(config);\n\n    let parser = code => {\n      return babylon.parse(code, option);\n    };\n\n    parser = _Plugin2.default.onHandleCodeParser(parser, option, filePath, code);\n\n    let ast = parser(code);\n\n    ast = _Plugin2.default.onHandleAST(ast, filePath, code);\n\n    return ast;\n  }\n\n  /**\n   * build babylon option.\n   * @param {ESDocConfig} config - config of esdoc\n   * @returns {{sourceType: string, plugins: string[]}} option of babylon.\n   * @private\n   */\n  static _buildParserOptionForBabylon(config) {\n    const option = {\n      sourceType: 'module',\n      plugins: ['jsx']\n    };\n\n    const experimental = config.experimentalProposal;\n\n    if (experimental) {\n      if (experimental.classProperties) option.plugins.push('classProperties');\n      if (experimental.objectRestSpread) option.plugins.push('objectRestSpread');\n      if (experimental.doExpressions) option.plugins.push('doExpressions');\n      if (experimental.functionBind) option.plugins.push('functionBind');\n      if (experimental.functionSent) option.plugins.push('functionSent');\n      if (experimental.asyncGenerators) option.plugins.push('asyncGenerators');\n      if (experimental.asyncGenerators) option.plugins.push('asyncGenerators');\n      if (experimental.decorators) option.plugins.push('decorators');\n      if (experimental.exportExtensions) option.plugins.push('exportExtensions');\n      if (experimental.dynamicImport) option.plugins.push('dynamicImport');\n    }\n\n    return option;\n  }\n}\nexports.default = ESParser;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Plugin/Plugin.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PluginEvent = undefined;\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Plugin system for your plugin.\n */\nclass Plugin {\n  /**\n   * create instance.\n   */\n  constructor() {\n    this._plugins = null;\n  }\n\n  /**\n   * initialize with plugin property.\n   * @param {Array<{name: string, option: object}>} plugins - expect config.plugins property.\n   */\n  init(plugins = []) {\n    this._plugins = copy(plugins);\n  }\n\n  /**\n   * exec plugin handler.\n   * @param {string} handlerName - handler name(e.g. onHandleCode)\n   * @param {PluginEvent} ev - plugin event object.\n   * @param {boolean} [giveOption=false] - if true, event has plugin option.\n   * @private\n   */\n  _execHandler(handlerName, ev, giveOption = false) {\n    /* eslint-disable global-require */\n    for (const item of this._plugins) {\n      let plugin;\n      if (item.name.match(/^[.\\/]/)) {\n        const pluginPath = _path2.default.resolve(item.name);\n        plugin = require(pluginPath);\n      } else {\n        module.paths.push('./node_modules');\n        plugin = require(item.name);\n        module.paths.pop();\n      }\n\n      if (!plugin[handlerName]) continue;\n\n      if (giveOption) ev.data.option = item.option;\n\n      plugin[handlerName](ev);\n    }\n  }\n\n  /**\n   * handle start.\n   */\n  onStart() {\n    const ev = new PluginEvent();\n    this._execHandler('onStart', ev, true);\n  }\n\n  /**\n   * handle config.\n   * @param {ESDocConfig} config - original esdoc config.\n   * @returns {ESDocConfig} handled config.\n   */\n  onHandleConfig(config) {\n    const ev = new PluginEvent({ config });\n    this._execHandler('onHandleConfig', ev);\n    return ev.data.config;\n  }\n\n  /**\n   * handle code.\n   * @param {string} code - original code.\n   * @param {string} filePath - source code file path.\n   * @returns {string} handled code.\n   */\n  onHandleCode(code, filePath) {\n    const ev = new PluginEvent({ code });\n    ev.data.filePath = filePath;\n    this._execHandler('onHandleCode', ev);\n    return ev.data.code;\n  }\n\n  /**\n   * handle code parser.\n   * @param {function(code: string)} parser - original js parser.\n   * @param {object} option - default Espree options.\n   * @param {string} filePath - source code file path.\n   * @param {string} code - original code.\n   * @returns {function(code: string)} handled parser.\n   */\n  onHandleCodeParser(parser, option, filePath, code) {\n    const ev = new PluginEvent();\n    ev.data = { parser, option, filePath, code };\n    this._execHandler('onHandleCodeParser', ev);\n    return ev.data.parser;\n  }\n\n  /**\n   * handle AST.\n   * @param {AST} ast - original ast.\n   * @param {string} filePath - source code file path.\n   * @param {string} code - original code.\n   * @returns {AST} handled AST.\n   */\n  onHandleAST(ast, filePath, code) {\n    const ev = new PluginEvent({ ast });\n    ev.data.filePath = filePath;\n    ev.data.code = code;\n    this._execHandler('onHandleAST', ev);\n    return ev.data.ast;\n  }\n\n  /**\n   * handle tag.\n   * @param {Tag} tag - original tag(s).\n   * @returns {Tag} handled tag.\n   */\n  onHandleTag(tag) {\n    const ev = new PluginEvent({ tag });\n    this._execHandler('onHandleTag', ev);\n    return ev.data.tag;\n  }\n\n  /**\n   * handle HTML.\n   * @param {string} html - original HTML.\n   * @param {string} fileName - the fileName of the HTML file.\n   * @returns {string} handled HTML.\n   */\n  onHandleHTML(html, fileName) {\n    const ev = new PluginEvent({ html, fileName });\n    this._execHandler('onHandleHTML', ev);\n    return ev.data.html;\n  }\n\n  /**\n   * handle complete\n   */\n  onComplete() {\n    const ev = new PluginEvent();\n    this._execHandler('onComplete', ev);\n  }\n}\n\n/**\n * Plugin Event class.\n */\nclass PluginEvent {\n  /**\n   * create instance.\n   * @param {Object} data - event content.\n   */\n  constructor(data = {}) {\n    this.data = copy(data);\n  }\n}\n\nexports.PluginEvent = PluginEvent;\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Instance of Plugin class.\n */\nexports.default = new Plugin();","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Util/PathResolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _assert = require('assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _os = require('os');\n\nvar _os2 = _interopRequireDefault(_os);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * file path resolver.\n * @example\n * let pathResolver = new PathResolver('./src', 'foo/bar.js', 'foo-bar', 'foo/bar.js');\n * pathResolver.importPath; // 'foo-bar'\n * pathResolver.filePath; // 'src/foo/bar.js'\n * pathResolver.resolve('./baz.js'); // 'src/foo/baz.js'\n */\nclass PathResolver {\n  /**\n   * create instance.\n   * @param {string} inDirPath - root directory path.\n   * @param {string} filePath - relative file path from root directory path.\n   * @param {string} [packageName] - npm package name.\n   * @param {string} [mainFilePath] - npm main file path.\n   */\n  constructor(inDirPath, filePath, packageName = null, mainFilePath = null) {\n    (0, _assert2.default)(inDirPath);\n    (0, _assert2.default)(filePath);\n\n    /** @type {string} */\n    this._inDirPath = _path2.default.resolve(inDirPath);\n\n    /** @type {string} */\n    this._filePath = _path2.default.resolve(filePath);\n\n    /** @type {NPMPackageObject} */\n    this._packageName = packageName;\n\n    if (mainFilePath) {\n      /** @type {string} */\n      this._mainFilePath = _path2.default.resolve(mainFilePath);\n    }\n  }\n\n  /**\n   * import path that is considered package name, main file and path prefix.\n   * @type {string}\n   */\n  get importPath() {\n    const relativeFilePath = this.filePath;\n\n    if (this._mainFilePath === _path2.default.resolve(relativeFilePath)) {\n      return this._packageName;\n    }\n\n    let filePath;\n    if (this._packageName) {\n      filePath = _path2.default.normalize(`${ this._packageName }${ _path2.default.sep }${ relativeFilePath }`);\n    } else {\n      filePath = `./${ relativeFilePath }`;\n    }\n\n    return this._slash(filePath);\n  }\n\n  /**\n   * file full path.\n   * @type {string}\n   */\n  get fileFullPath() {\n    return this._slash(this._filePath);\n  }\n\n  /**\n   * file path that is relative path on root dir.\n   * @type {string}\n   */\n  get filePath() {\n    const relativeFilePath = _path2.default.relative(_path2.default.dirname(this._inDirPath), this._filePath);\n    return this._slash(relativeFilePath);\n  }\n\n  /**\n   * resolve file path on this file.\n   * @param {string} relativePath - relative path on this file.\n   */\n  resolve(relativePath) {\n    const selfDirPath = _path2.default.dirname(this._filePath);\n    const resolvedPath = _path2.default.resolve(selfDirPath, relativePath);\n    const resolvedRelativePath = _path2.default.relative(_path2.default.dirname(this._inDirPath), resolvedPath);\n    return this._slash(resolvedRelativePath);\n  }\n\n  /**\n   * convert 'back slash' to 'slash'.\n   * path separator is 'back slash' if platform is windows.\n   * @param {string} filePath - target file path.\n   * @returns {string} converted path.\n   * @private\n   */\n  _slash(filePath) {\n    if (_os2.default.platform() === 'win32') {\n      filePath = filePath.replace(/\\\\/g, '/');\n    }\n\n    return filePath;\n  }\n}\nexports.default = PathResolver;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Factory/DocFactory.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _colorLogger = require('color-logger');\n\nvar _colorLogger2 = _interopRequireDefault(_colorLogger);\n\nvar _CommentParser = require('../Parser/CommentParser.js');\n\nvar _CommentParser2 = _interopRequireDefault(_CommentParser);\n\nvar _FileDoc = require('../Doc/FileDoc.js');\n\nvar _FileDoc2 = _interopRequireDefault(_FileDoc);\n\nvar _ClassDoc = require('../Doc/ClassDoc.js');\n\nvar _ClassDoc2 = _interopRequireDefault(_ClassDoc);\n\nvar _MethodDoc = require('../Doc/MethodDoc.js');\n\nvar _MethodDoc2 = _interopRequireDefault(_MethodDoc);\n\nvar _ClassPropertyDoc = require('../Doc/ClassPropertyDoc');\n\nvar _ClassPropertyDoc2 = _interopRequireDefault(_ClassPropertyDoc);\n\nvar _MemberDoc = require('../Doc/MemberDoc.js');\n\nvar _MemberDoc2 = _interopRequireDefault(_MemberDoc);\n\nvar _FunctionDoc = require('../Doc/FunctionDoc.js');\n\nvar _FunctionDoc2 = _interopRequireDefault(_FunctionDoc);\n\nvar _VariableDoc = require('../Doc/VariableDoc.js');\n\nvar _VariableDoc2 = _interopRequireDefault(_VariableDoc);\n\nvar _AssignmentDoc = require('../Doc/AssignmentDoc.js');\n\nvar _AssignmentDoc2 = _interopRequireDefault(_AssignmentDoc);\n\nvar _TypedefDoc = require('../Doc/TypedefDoc.js');\n\nvar _TypedefDoc2 = _interopRequireDefault(_TypedefDoc);\n\nvar _ExternalDoc = require('../Doc/ExternalDoc.js');\n\nvar _ExternalDoc2 = _interopRequireDefault(_ExternalDoc);\n\nvar _ASTUtil = require('../Util/ASTUtil.js');\n\nvar _ASTUtil2 = _interopRequireDefault(_ASTUtil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst already = Symbol('already');\nconst logger = new _colorLogger2.default('DocFactory');\n\n/**\n * Doc factory class.\n *\n * @example\n * let factory = new DocFactory(ast, pathResolver);\n * factory.push(node, parentNode);\n * let results = factory.results;\n */\nclass DocFactory {\n  /**\n   * @type {DocObject[]}\n   */\n  get results() {\n    return [...this._results];\n  }\n\n  /**\n   * create instance.\n   * @param {AST} ast - AST of source code.\n   * @param {PathResolver} pathResolver - path resolver of source code.\n   */\n  constructor(ast, pathResolver) {\n    this._ast = ast;\n    this._pathResolver = pathResolver;\n    this._results = [];\n    this._processedClassNodes = [];\n\n    this._inspectExportDefaultDeclaration();\n    this._inspectExportNamedDeclaration();\n\n    // file doc\n    const doc = new _FileDoc2.default(ast, ast, pathResolver, []);\n    this._results.push(doc.value);\n\n    // ast does not child, so only comment.\n    if (ast.program.body.length === 0 && ast.program.innerComments) {\n      const results = this._traverseComments(ast, null, ast.program.innerComments);\n      this._results.push(...results);\n    }\n  }\n\n  /**\n   * inspect ExportDefaultDeclaration.\n   *\n   * case1: separated export\n   *\n   * ```javascript\n   * class Foo {}\n   * export default Foo;\n   * ```\n   *\n   * case2: export instance(directly).\n   *\n   * ```javascript\n   * class Foo {}\n   * export default new Foo();\n   * ```\n   *\n   * case3: export instance(indirectly).\n   *\n   * ```javascript\n   * class Foo {}\n   * let foo = new Foo();\n   * export default foo;\n   * ```\n   *\n   * @private\n   * @todo support function export.\n   */\n  _inspectExportDefaultDeclaration() {\n    const pseudoExportNodes = [];\n\n    for (const exportNode of this._ast.program.body) {\n      if (exportNode.type !== 'ExportDefaultDeclaration') continue;\n\n      let targetClassName = null;\n      let targetVariableName = null;\n      let pseudoClassExport;\n\n      switch (exportNode.declaration.type) {\n        case 'NewExpression':\n          if (exportNode.declaration.callee.type === 'Identifier') {\n            targetClassName = exportNode.declaration.callee.name;\n          } else if (exportNode.declaration.callee.type === 'MemberExpression') {\n            targetClassName = exportNode.declaration.callee.property.name;\n          } else {\n            targetClassName = '';\n          }\n          targetVariableName = targetClassName.replace(/^./, c => c.toLowerCase());\n          pseudoClassExport = true;\n          break;\n        case 'Identifier':\n          {\n            const varNode = _ASTUtil2.default.findVariableDeclarationAndNewExpressionNode(exportNode.declaration.name, this._ast);\n            if (varNode) {\n              targetClassName = varNode.declarations[0].init.callee.name;\n              targetVariableName = exportNode.declaration.name;\n              pseudoClassExport = true;\n              _ASTUtil2.default.sanitize(varNode);\n            } else {\n              targetClassName = exportNode.declaration.name;\n              pseudoClassExport = false;\n            }\n            break;\n          }\n        default:\n          logger.w(`unknown export declaration type. type = \"${ exportNode.declaration.type }\"`);\n          break;\n      }\n\n      const classNode = _ASTUtil2.default.findClassDeclarationNode(targetClassName, this._ast);\n      if (classNode) {\n        const pseudoExportNode1 = this._copy(exportNode);\n        pseudoExportNode1.declaration = this._copy(classNode);\n        pseudoExportNode1.leadingComments = null;\n        pseudoExportNode1.declaration.__PseudoExport__ = pseudoClassExport;\n        pseudoExportNodes.push(pseudoExportNode1);\n\n        if (targetVariableName) {\n          const pseudoExportNode2 = this._copy(exportNode);\n          pseudoExportNode2.declaration = _ASTUtil2.default.createVariableDeclarationAndNewExpressionNode(targetVariableName, targetClassName, exportNode.loc);\n          pseudoExportNodes.push(pseudoExportNode2);\n        }\n\n        _ASTUtil2.default.sanitize(classNode);\n        _ASTUtil2.default.sanitize(exportNode);\n      }\n\n      const functionNode = _ASTUtil2.default.findFunctionDeclarationNode(exportNode.declaration.name, this._ast);\n      if (functionNode) {\n        const pseudoExportNode = this._copy(exportNode);\n        pseudoExportNode.declaration = this._copy(functionNode);\n        _ASTUtil2.default.sanitize(exportNode);\n        _ASTUtil2.default.sanitize(functionNode);\n        pseudoExportNodes.push(pseudoExportNode);\n      }\n\n      const variableNode = _ASTUtil2.default.findVariableDeclarationNode(exportNode.declaration.name, this._ast);\n      if (variableNode) {\n        const pseudoExportNode = this._copy(exportNode);\n        pseudoExportNode.declaration = this._copy(variableNode);\n        _ASTUtil2.default.sanitize(exportNode);\n        _ASTUtil2.default.sanitize(variableNode);\n        pseudoExportNodes.push(pseudoExportNode);\n      }\n    }\n\n    this._ast.program.body.push(...pseudoExportNodes);\n  }\n\n  /* eslint-disable max-statements */\n  /**\n   * inspect ExportNamedDeclaration.\n   *\n   * case1: separated export\n   *\n   * ```javascript\n   * class Foo {}\n   * export {Foo};\n   * ```\n   *\n   * case2: export instance(indirectly).\n   *\n   * ```javascript\n   * class Foo {}\n   * let foo = new Foo();\n   * export {foo};\n   * ```\n   *\n   * @private\n   * @todo support function export.\n   */\n  _inspectExportNamedDeclaration() {\n    const pseudoExportNodes = [];\n\n    for (const exportNode of this._ast.program.body) {\n      if (exportNode.type !== 'ExportNamedDeclaration') continue;\n\n      if (exportNode.declaration && exportNode.declaration.type === 'VariableDeclaration') {\n        for (const declaration of exportNode.declaration.declarations) {\n          if (!declaration.init || declaration.init.type !== 'NewExpression') continue;\n\n          const classNode = _ASTUtil2.default.findClassDeclarationNode(declaration.init.callee.name, this._ast);\n          if (classNode) {\n            const pseudoExportNode = this._copy(exportNode);\n            pseudoExportNode.declaration = this._copy(classNode);\n            pseudoExportNode.leadingComments = null;\n            pseudoExportNodes.push(pseudoExportNode);\n            pseudoExportNode.declaration.__PseudoExport__ = true;\n            _ASTUtil2.default.sanitize(classNode);\n          }\n        }\n        continue;\n      }\n\n      for (const specifier of exportNode.specifiers) {\n        if (specifier.type !== 'ExportSpecifier') continue;\n\n        let targetClassName = null;\n        let pseudoClassExport;\n\n        const varNode = _ASTUtil2.default.findVariableDeclarationAndNewExpressionNode(specifier.exported.name, this._ast);\n        if (varNode) {\n          targetClassName = varNode.declarations[0].init.callee.name;\n          pseudoClassExport = true;\n\n          const pseudoExportNode = this._copy(exportNode);\n          pseudoExportNode.declaration = this._copy(varNode);\n          pseudoExportNode.specifiers = null;\n          pseudoExportNodes.push(pseudoExportNode);\n\n          _ASTUtil2.default.sanitize(varNode);\n        } else {\n          targetClassName = specifier.exported.name;\n          pseudoClassExport = false;\n        }\n\n        const classNode = _ASTUtil2.default.findClassDeclarationNode(targetClassName, this._ast);\n        if (classNode) {\n          const pseudoExportNode = this._copy(exportNode);\n          pseudoExportNode.declaration = this._copy(classNode);\n          pseudoExportNode.leadingComments = null;\n          pseudoExportNode.specifiers = null;\n          pseudoExportNode.declaration.__PseudoExport__ = pseudoClassExport;\n          pseudoExportNodes.push(pseudoExportNode);\n          _ASTUtil2.default.sanitize(classNode);\n        }\n\n        const functionNode = _ASTUtil2.default.findFunctionDeclarationNode(specifier.exported.name, this._ast);\n        if (functionNode) {\n          const pseudoExportNode = this._copy(exportNode);\n          pseudoExportNode.declaration = this._copy(functionNode);\n          pseudoExportNode.leadingComments = null;\n          pseudoExportNode.specifiers = null;\n          _ASTUtil2.default.sanitize(functionNode);\n          pseudoExportNodes.push(pseudoExportNode);\n        }\n\n        const variableNode = _ASTUtil2.default.findVariableDeclarationNode(specifier.exported.name, this._ast);\n        if (variableNode) {\n          const pseudoExportNode = this._copy(exportNode);\n          pseudoExportNode.declaration = this._copy(variableNode);\n          pseudoExportNode.leadingComments = null;\n          pseudoExportNode.specifiers = null;\n          _ASTUtil2.default.sanitize(variableNode);\n          pseudoExportNodes.push(pseudoExportNode);\n        }\n      }\n    }\n\n    this._ast.program.body.push(...pseudoExportNodes);\n  }\n\n  /**\n   * push node, and factory processes node.\n   * @param {ASTNode} node - target node.\n   * @param {ASTNode} parentNode - parent node of target node.\n   */\n  push(node, parentNode) {\n    if (node === this._ast) return;\n\n    if (node[already]) return;\n\n    const isLastNodeInParent = this._isLastNodeInParent(node, parentNode);\n\n    node[already] = true;\n    Reflect.defineProperty(node, 'parent', { value: parentNode });\n\n    // unwrap export declaration\n    if (['ExportDefaultDeclaration', 'ExportNamedDeclaration'].includes(node.type)) {\n      parentNode = node;\n      node = this._unwrapExportDeclaration(node);\n      if (!node) return;\n      node[already] = true;\n      Reflect.defineProperty(node, 'parent', { value: parentNode });\n    }\n\n    // if node has decorators, leading comments is attached to decorators.\n    if (node.decorators && node.decorators[0].leadingComments) {\n      if (!node.leadingComments || !node.leadingComments.length) {\n        node.leadingComments = node.decorators[0].leadingComments;\n      }\n    }\n\n    let results;\n    results = this._traverseComments(parentNode, node, node.leadingComments);\n    this._results.push(...results);\n\n    // for trailing comments.\n    // traverse with only last node, because prevent duplication of trailing comments.\n    if (node.trailingComments && isLastNodeInParent) {\n      results = this._traverseComments(parentNode, null, node.trailingComments);\n      this._results.push(...results);\n    }\n  }\n\n  /**\n   * traverse comments of node, and create doc object.\n   * @param {ASTNode|AST} parentNode - parent of target node.\n   * @param {?ASTNode} node - target node.\n   * @param {ASTNode[]} comments - comment nodes.\n   * @returns {DocObject[]} created doc objects.\n   * @private\n   */\n  _traverseComments(parentNode, node, comments) {\n    if (!node) {\n      const virtualNode = {};\n      Reflect.defineProperty(virtualNode, 'parent', { value: parentNode });\n      node = virtualNode;\n    }\n\n    if (comments && comments.length) {\n      const temp = [];\n      for (const comment of comments) {\n        if (_CommentParser2.default.isESDoc(comment)) temp.push(comment);\n      }\n      comments = temp;\n    } else {\n      comments = [];\n    }\n\n    if (comments.length === 0) {\n      comments = [{ type: 'CommentBlock', value: '* @_undocument' }];\n    }\n\n    const results = [];\n    const lastComment = comments[comments.length - 1];\n    for (const comment of comments) {\n      const tags = _CommentParser2.default.parse(comment);\n\n      let doc;\n      if (comment === lastComment) {\n        doc = this._createDoc(node, tags);\n      } else {\n        const virtualNode = {};\n        Reflect.defineProperty(virtualNode, 'parent', { value: parentNode });\n        doc = this._createDoc(virtualNode, tags);\n      }\n\n      if (doc) results.push(doc.value);\n    }\n\n    return results;\n  }\n\n  /**\n   * create Doc.\n   * @param {ASTNode} node - target node.\n   * @param {Tag[]} tags - tags of target node.\n   * @returns {AbstractDoc} created Doc.\n   * @private\n   */\n  _createDoc(node, tags) {\n    const result = this._decideType(tags, node);\n    const type = result.type;\n    node = result.node;\n\n    if (!type) return null;\n\n    if (type === 'Class') {\n      this._processedClassNodes.push(node);\n    }\n\n    let Clazz;\n    /* eslint-disable max-statements-per-line */\n    switch (type) {\n      case 'Class':\n        Clazz = _ClassDoc2.default;break;\n      case 'Method':\n        Clazz = _MethodDoc2.default;break;\n      case 'ClassProperty':\n        Clazz = _ClassPropertyDoc2.default;break;\n      case 'Member':\n        Clazz = _MemberDoc2.default;break;\n      case 'Function':\n        Clazz = _FunctionDoc2.default;break;\n      case 'Variable':\n        Clazz = _VariableDoc2.default;break;\n      case 'Assignment':\n        Clazz = _AssignmentDoc2.default;break;\n      case 'Typedef':\n        Clazz = _TypedefDoc2.default;break;\n      case 'External':\n        Clazz = _ExternalDoc2.default;break;\n      default:\n        throw new Error(`unexpected type: ${ type }`);\n    }\n\n    if (!Clazz) return null;\n    if (!node.type) node.type = type;\n\n    return new Clazz(this._ast, node, this._pathResolver, tags);\n  }\n\n  /**\n   * decide Doc type by using tags and node.\n   * @param {Tag[]} tags - tags of node.\n   * @param {ASTNode} node - target node.\n   * @returns {{type: ?string, node: ?ASTNode}} decided type.\n   * @private\n   */\n  _decideType(tags, node) {\n    let type = null;\n    for (const tag of tags) {\n      const tagName = tag.tagName;\n      /* eslint-disable default-case */\n      switch (tagName) {\n        case '@typedef':\n          type = 'Typedef';break;\n        case '@external':\n          type = 'External';break;\n      }\n    }\n\n    if (type) return { type, node };\n\n    if (!node) return { type, node };\n\n    /* eslint-disable default-case */\n    switch (node.type) {\n      case 'ClassDeclaration':\n        return this._decideClassDeclarationType(node);\n      case 'ClassMethod':\n        return this._decideMethodDefinitionType(node);\n      case 'ClassProperty':\n        return this._decideClassPropertyType(node);\n      case 'ExpressionStatement':\n        return this._decideExpressionStatementType(node);\n      case 'FunctionDeclaration':\n        return this._decideFunctionDeclarationType(node);\n      case 'FunctionExpression':\n        return this._decideFunctionExpressionType(node);\n      case 'VariableDeclaration':\n        return this._decideVariableType(node);\n      case 'AssignmentExpression':\n        return this._decideAssignmentType(node);\n      case 'ArrowFunctionExpression':\n        return this._decideArrowFunctionExpressionType(node);\n    }\n\n    return { type: null, node: null };\n  }\n\n  /**\n   * decide Doc type from class declaration node.\n   * @param {ASTNode} node - target node that is class declaration node.\n   * @returns {{type: string, node: ASTNode}} decided type.\n   * @private\n   */\n  _decideClassDeclarationType(node) {\n    if (!this._isTopDepthInBody(node, this._ast.program.body)) return { type: null, node: null };\n\n    return { type: 'Class', node: node };\n  }\n\n  /**\n   * decide Doc type from method definition node.\n   * @param {ASTNode} node - target node that is method definition node.\n   * @returns {{type: ?string, node: ?ASTNode}} decided type.\n   * @private\n   */\n  _decideMethodDefinitionType(node) {\n    const classNode = this._findUp(node, ['ClassDeclaration', 'ClassExpression']);\n    if (this._processedClassNodes.includes(classNode)) {\n      return { type: 'Method', node: node };\n    } else {\n      logger.w('this method is not in class', node);\n      return { type: null, node: null };\n    }\n  }\n\n  /**\n   * decide Doc type from class property node.\n   * @param {ASTNode} node - target node that is classs property node.\n   * @returns {{type: ?string, node: ?ASTNode}} decided type.\n   * @private\n   */\n  _decideClassPropertyType(node) {\n    const classNode = this._findUp(node, ['ClassDeclaration', 'ClassExpression']);\n    if (this._processedClassNodes.includes(classNode)) {\n      return { type: 'ClassProperty', node: node };\n    } else {\n      logger.w('this class property is not in class', node);\n      return { type: null, node: null };\n    }\n  }\n\n  /**\n   * decide Doc type from function declaration node.\n   * @param {ASTNode} node - target node that is function declaration node.\n   * @returns {{type: string, node: ASTNode}} decided type.\n   * @private\n   */\n  _decideFunctionDeclarationType(node) {\n    if (!this._isTopDepthInBody(node, this._ast.program.body)) return { type: null, node: null };\n\n    return { type: 'Function', node: node };\n  }\n\n  /**\n   * decide Doc type from function expression node.\n   * babylon 6.11.2 judges`export default async function foo(){}` to be `FunctionExpression`.\n   * I expect `FunctionDeclaration`. this behavior may be bug of babylon.\n   * for now, workaround for it with this method.\n   * @param {ASTNode} node - target node that is function expression node.\n   * @returns {{type: string, node: ASTNode}} decided type.\n   * @private\n   * @todo inspect with newer babylon.\n   */\n  _decideFunctionExpressionType(node) {\n    if (!node.async) return { type: null, node: null };\n    if (!this._isTopDepthInBody(node, this._ast.program.body)) return { type: null, node: null };\n\n    return { type: 'Function', node: node };\n  }\n\n  /**\n   * decide Doc type from arrow function expression node.\n   * @param {ASTNode} node - target node that is arrow function expression node.\n   * @returns {{type: string, node: ASTNode}} decided type.\n   * @private\n   */\n  _decideArrowFunctionExpressionType(node) {\n    if (!this._isTopDepthInBody(node, this._ast.program.body)) return { type: null, node: null };\n\n    return { type: 'Function', node: node };\n  }\n\n  /**\n   * decide Doc type from expression statement node.\n   * @param {ASTNode} node - target node that is expression statement node.\n   * @returns {{type: ?string, node: ?ASTNode}} decided type.\n   * @private\n   */\n  _decideExpressionStatementType(node) {\n    const isTop = this._isTopDepthInBody(node, this._ast.program.body);\n    Reflect.defineProperty(node.expression, 'parent', { value: node });\n    node = node.expression;\n    node[already] = true;\n\n    let innerType;\n    let innerNode;\n\n    if (!node.right) return { type: null, node: null };\n\n    switch (node.right.type) {\n      case 'FunctionExpression':\n        innerType = 'Function';\n        break;\n      case 'ClassExpression':\n        innerType = 'Class';\n        break;\n      default:\n        if (node.left.type === 'MemberExpression' && node.left.object.type === 'ThisExpression') {\n          const classNode = this._findUp(node, ['ClassExpression', 'ClassDeclaration']);\n          if (!this._processedClassNodes.includes(classNode)) {\n            logger.w('this member is not in class.', this._pathResolver.filePath, node);\n            return { type: null, node: null };\n          }\n\n          return { type: 'Member', node: node };\n        } else {\n          return { type: null, node: null };\n        }\n    }\n\n    if (!isTop) return { type: null, node: null };\n\n    /* eslint-disable prefer-const */\n    innerNode = node.right;\n    innerNode.id = this._copy(node.left.id || node.left.property);\n    Reflect.defineProperty(innerNode, 'parent', { value: node });\n    innerNode[already] = true;\n\n    return { type: innerType, node: innerNode };\n  }\n\n  /**\n   * decide Doc type from variable node.\n   * @param {ASTNode} node - target node that is variable node.\n   * @returns {{type: string, node: ASTNode}} decided type.\n   * @private\n   */\n  _decideVariableType(node) {\n    if (!this._isTopDepthInBody(node, this._ast.program.body)) return { type: null, node: null };\n\n    let innerType = null;\n    let innerNode = null;\n\n    if (!node.declarations[0].init) return { type: innerType, node: innerNode };\n\n    switch (node.declarations[0].init.type) {\n      case 'FunctionExpression':\n        innerType = 'Function';\n        break;\n      case 'ClassExpression':\n        innerType = 'Class';\n        break;\n      case 'ArrowFunctionExpression':\n        innerType = 'Function';\n        break;\n      default:\n        return { type: 'Variable', node: node };\n    }\n\n    innerNode = node.declarations[0].init;\n    innerNode.id = this._copy(node.declarations[0].id);\n    Reflect.defineProperty(innerNode, 'parent', { value: node });\n    innerNode[already] = true;\n\n    return { type: innerType, node: innerNode };\n  }\n\n  /**\n   * decide Doc type from assignment node.\n   * @param {ASTNode} node - target node that is assignment node.\n   * @returns {{type: string, node: ASTNode}} decided type.\n   * @private\n   */\n  _decideAssignmentType(node) {\n    if (!this._isTopDepthInBody(node, this._ast.program.body)) return { type: null, node: null };\n\n    let innerType;\n    let innerNode;\n\n    switch (node.right.type) {\n      case 'FunctionExpression':\n        innerType = 'Function';\n        break;\n      case 'ClassExpression':\n        innerType = 'Class';\n        break;\n      default:\n        return { type: 'Assignment', node: node };\n    }\n\n    /* eslint-disable prefer-const */\n    innerNode = node.right;\n    innerNode.id = this._copy(node.left.id || node.left.property);\n    Reflect.defineProperty(innerNode, 'parent', { value: node });\n    innerNode[already] = true;\n\n    return { type: innerType, node: innerNode };\n  }\n\n  /**\n   * unwrap exported node.\n   * @param {ASTNode} node - target node that is export declaration node.\n   * @returns {ASTNode|null} unwrapped child node of exported node.\n   * @private\n   */\n  _unwrapExportDeclaration(node) {\n    // e.g. `export A from './A.js'` has not declaration\n    if (!node.declaration) return null;\n\n    const exportedASTNode = node.declaration;\n    if (!exportedASTNode.leadingComments) exportedASTNode.leadingComments = [];\n    exportedASTNode.leadingComments.push(...(node.leadingComments || []));\n\n    if (!exportedASTNode.trailingComments) exportedASTNode.trailingComments = [];\n    exportedASTNode.trailingComments.push(...(node.trailingComments || []));\n\n    return exportedASTNode;\n  }\n\n  /**\n   * judge node is last in parent.\n   * @param {ASTNode} node - target node.\n   * @param {ASTNode} parentNode - target parent node.\n   * @returns {boolean} if true, the node is last in parent.\n   * @private\n   */\n  _isLastNodeInParent(node, parentNode) {\n    if (parentNode && parentNode.body) {\n      const lastNode = parentNode.body[parentNode.body.length - 1];\n      return node === lastNode;\n    }\n\n    return false;\n  }\n\n  /**\n   * judge node is top in body.\n   * @param {ASTNode} node - target node.\n   * @param {ASTNode[]} body - target body node.\n   * @returns {boolean} if true, the node is top in body.\n   * @private\n   */\n  _isTopDepthInBody(node, body) {\n    if (!body) return false;\n    if (!Array.isArray(body)) return false;\n\n    const parentNode = node.parent;\n    if (['ExportDefaultDeclaration', 'ExportNamedDeclaration'].includes(parentNode.type)) {\n      node = parentNode;\n    }\n\n    for (const _node of body) {\n      if (node === _node) return true;\n    }\n    return false;\n  }\n\n  /**\n   * deep copy object.\n   * @param {Object} obj - target object.\n   * @return {Object} copied object.\n   * @private\n   */\n  _copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  /**\n   * find node while goes up.\n   * @param {ASTNode} node - start node.\n   * @param {string[]} types - ASTNode types.\n   * @returns {ASTNode|null} found first node.\n   * @private\n   */\n  _findUp(node, types) {\n    let parent = node.parent;\n    while (parent) {\n      if (types.includes(parent.type)) return parent;\n      parent = parent.parent;\n    }\n\n    return null;\n  }\n}\nexports.default = DocFactory;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Parser/CommentParser.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Doc Comment Parser class.\n *\n * @example\n * for (let comment of node.leadingComments) {\n *   let tags = CommentParser.parse(comment);\n *   console.log(tags);\n * }\n */\nclass CommentParser {\n  /**\n   * parse comment to tags.\n   * @param {ASTNode} commentNode - comment node.\n   * @param {string} commentNode.value - comment body.\n   * @param {string} commentNode.type - CommentBlock or CommentLine.\n   * @returns {Tag[]} parsed comment.\n   */\n  static parse(commentNode) {\n    if (!this.isESDoc(commentNode)) return [];\n\n    let comment = commentNode.value;\n\n    // TODO: refactor\n    comment = comment.replace(/\\r\\n/gm, '\\n'); // for windows\n    comment = comment.replace(/^[\\t ]*/gm, ''); // remove line head space\n    comment = comment.replace(/^\\*[\\t ]?/, ''); // remove first '*'\n    comment = comment.replace(/[\\t ]$/, ''); // remove last space\n    comment = comment.replace(/^\\*[\\t ]?/gm, ''); // remove line head '*'\n    if (comment.charAt(0) !== '@') comment = `@desc ${ comment }`; // auto insert @desc\n    comment = comment.replace(/[\\t ]*$/, ''); // remove tail space.\n    comment = comment.replace(/^[\\t ]*(@\\w+)$/gm, '$1 \\\\TRUE'); // auto insert tag text to non-text tag (e.g. @interface)\n    comment = comment.replace(/^[\\t ]*(@\\w+)[\\t ](.*)/gm, '\\\\Z$1\\\\Z$2'); // insert separator (\\\\Z@tag\\\\Ztext)\n    const lines = comment.split('\\\\Z');\n\n    let tagName = '';\n    let tagValue = '';\n    const tags = [];\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (line.charAt(0) === '@') {\n        tagName = line;\n        const nextLine = lines[i + 1];\n        if (nextLine.charAt(0) === '@') {\n          tagValue = '';\n        } else {\n          tagValue = nextLine;\n          i++;\n        }\n        tagValue = tagValue.replace('\\\\TRUE', '').replace(/^\\n/, '').replace(/\\n*$/, '');\n        tags.push({ tagName, tagValue });\n      }\n    }\n    return tags;\n  }\n\n  /**\n   * judge doc comment or not.\n   * @param {ASTNode} commentNode - comment node.\n   * @returns {boolean} if true, this comment node is doc comment.\n   */\n  static isESDoc(commentNode) {\n    if (commentNode.type !== 'CommentBlock') return false;\n    return commentNode.value.charAt(0) === '*';\n  }\n}\nexports.default = CommentParser;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/FileDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class from source file.\n */\nclass FileDoc extends _AbstractDoc2.default {\n  /**\n   * apply own tag.\n   * @private\n   */\n  _apply() {\n    super._apply();\n\n    Reflect.deleteProperty(this._value, 'export');\n    Reflect.deleteProperty(this._value, 'importPath');\n    Reflect.deleteProperty(this._value, 'importStyle');\n  }\n\n  /** specify ``file`` to kind. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'file';\n  }\n\n  /** take out self name from file path */\n  _$name() {\n    super._$name();\n    this._value.name = this._pathResolver.filePath;\n  }\n\n  /** specify name to longname */\n  _$longname() {\n    this._value.longname = this._value.name;\n  }\n\n  /** specify file content to value.content */\n  _$content() {\n    super._$content();\n\n    const filePath = this._pathResolver.fileFullPath;\n    const content = _fs2.default.readFileSync(filePath, { encode: 'utf8' }).toString();\n    this._value.content = content;\n  }\n}\nexports.default = FileDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/AbstractDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nvar _ASTUtil = require('../Util/ASTUtil.js');\n\nvar _ASTUtil2 = _interopRequireDefault(_ASTUtil);\n\nvar _InvalidCodeLogger = require('../Util/InvalidCodeLogger.js');\n\nvar _InvalidCodeLogger2 = _interopRequireDefault(_InvalidCodeLogger);\n\nvar _ASTNodeContainer = require('../Util/ASTNodeContainer.js');\n\nvar _ASTNodeContainer2 = _interopRequireDefault(_ASTNodeContainer);\n\nvar _babelGenerator = require('babel-generator');\n\nvar _babelGenerator2 = _interopRequireDefault(_babelGenerator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Abstract Doc Class.\n * @todo rename this class name.\n */\nclass AbstractDoc {\n  /**\n   * create instance.\n   * @param {AST} ast - this is AST that contains this doc.\n   * @param {ASTNode} node - this is self node.\n   * @param {PathResolver} pathResolver - this is file path resolver that contains this doc.\n   * @param {Tag[]} commentTags - this is tags that self node has.\n   */\n  constructor(ast, node, pathResolver, commentTags = []) {\n    this._ast = ast;\n    this._node = node;\n    this._pathResolver = pathResolver;\n    this._commentTags = commentTags;\n    this._value = {};\n\n    Reflect.defineProperty(this._node, 'doc', { value: this });\n\n    this._value.__docId__ = _ASTNodeContainer2.default.addNode(node);\n\n    this._apply();\n  }\n\n  /** @type {DocObject[]} */\n  get value() {\n    return JSON.parse(JSON.stringify(this._value));\n  }\n\n  /**\n   * apply doc comment.\n   * @protected\n   */\n  _apply() {\n    this._$kind();\n    this._$variation();\n    this._$name();\n    this._$memberof();\n    this._$member();\n    this._$content();\n    this._$generator();\n    this._$async();\n\n    this._$static();\n    this._$longname();\n    this._$access();\n    this._$export();\n    this._$importPath();\n    this._$importStyle();\n    this._$desc();\n    this._$example();\n    this._$see();\n    this._$lineNumber();\n    this._$deprecated();\n    this._$experimental();\n    this._$since();\n    this._$version();\n    this._$todo();\n    this._$ignore();\n    this._$pseudoExport();\n    this._$undocument();\n    this._$unknown();\n    this._$param();\n    this._$property();\n    this._$return();\n    this._$type();\n    this._$abstract();\n    this._$override();\n    this._$throws();\n    this._$emits();\n    this._$listens();\n    this._$decorator();\n  }\n\n  /**\n   * decide `kind`.\n   * @abstract\n   */\n  _$kind() {}\n\n  /** for @_variation */\n  /**\n   * decide `variation`.\n   * @todo implements `@variation`.\n   * @abstract\n   */\n  _$variation() {}\n\n  /**\n   * decide `name`\n   * @abstract\n   */\n  _$name() {}\n\n  /**\n   * decide `memberof`.\n   * @abstract\n   */\n  _$memberof() {}\n\n  /**\n   * decide `member`.\n   * @abstract\n   */\n  _$member() {}\n\n  /**\n   * decide `content`.\n   * @abstract\n   */\n  _$content() {}\n\n  /**\n   * decide `generator`.\n   * @abstract\n   */\n  _$generator() {}\n\n  /**\n   * decide `async`.\n   * @abstract\n   */\n  _$async() {}\n\n  /**\n   * decide `static`.\n   */\n  _$static() {\n    if ('static' in this._node) {\n      this._value.static = this._node.static;\n    } else {\n      this._value.static = true;\n    }\n  }\n\n  /**\n   * decide `longname`.\n   */\n  _$longname() {\n    const memberof = this._value.memberof;\n    const name = this._value.name;\n    const scope = this._value.static ? '.' : '#';\n    if (memberof.includes('~')) {\n      this._value.longname = `${ memberof }${ scope }${ name }`;\n    } else {\n      this._value.longname = `${ memberof }~${ name }`;\n    }\n  }\n\n  /**\n   * decide `access`.\n   * process also @public, @private and @protected.\n   */\n  _$access() {\n    const tag = this._find(['@access', '@public', '@private', '@protected']);\n    if (tag) {\n      let access;\n      /* eslint-disable max-statements-per-line */\n      switch (tag.tagName) {\n        case '@access':\n          access = tag.tagValue;break;\n        case '@public':\n          access = 'public';break;\n        case '@protected':\n          access = 'protected';break;\n        case '@private':\n          access = 'private';break;\n        default:\n          throw new Error(`unexpected token: ${ tag.tagName }`);\n      }\n\n      this._value.access = access;\n    } else {\n      this._value.access = null;\n    }\n  }\n\n  /**\n   * avoid unknown tag.\n   */\n  _$public() {}\n\n  /**\n   * avoid unknown tag.\n   */\n  _$protected() {}\n\n  /**\n   * avoid unknown tag.\n   */\n  _$private() {}\n\n  /**\n   * decide `export`.\n   */\n  _$export() {\n    let parent = this._node.parent;\n    while (parent) {\n      if (parent.type === 'ExportDefaultDeclaration') {\n        this._value.export = true;\n        return;\n      } else if (parent.type === 'ExportNamedDeclaration') {\n        this._value.export = true;\n        return;\n      }\n\n      parent = parent.parent;\n    }\n\n    this._value.export = false;\n  }\n\n  /**\n   * decide `importPath`.\n   */\n  _$importPath() {\n    this._value.importPath = this._pathResolver.importPath;\n  }\n\n  /**\n   * decide `importStyle`.\n   */\n  _$importStyle() {\n    if (this._node.__PseudoExport__) {\n      this._value.importStyle = null;\n      return;\n    }\n\n    let parent = this._node.parent;\n    const name = this._value.name;\n    while (parent) {\n      if (parent.type === 'ExportDefaultDeclaration') {\n        this._value.importStyle = name;\n        return;\n      } else if (parent.type === 'ExportNamedDeclaration') {\n        this._value.importStyle = `{${ name }}`;\n        return;\n      }\n      parent = parent.parent;\n    }\n\n    this._value.importStyle = null;\n  }\n\n  /**\n   * decide `description`.\n   */\n  _$desc() {\n    this._value.description = this._findTagValue(['@desc']);\n  }\n\n  /**\n   * decide `examples`.\n   */\n  _$example() {\n    const tags = this._findAll(['@example']);\n    if (!tags) return;\n    if (!tags.length) return;\n\n    this._value.examples = [];\n    for (const tag of tags) {\n      this._value.examples.push(tag.tagValue);\n    }\n  }\n\n  /**\n   * decide `see`.\n   */\n  _$see() {\n    const tags = this._findAll(['@see']);\n    if (!tags) return;\n    if (!tags.length) return;\n\n    this._value.see = [];\n    for (const tag of tags) {\n      this._value.see.push(tag.tagValue);\n    }\n  }\n\n  /**\n   * decide `lineNumber`.\n   */\n  _$lineNumber() {\n    const node = this._node;\n    if (node.loc) {\n      this._value.lineNumber = node.loc.start.line;\n    }\n  }\n\n  /**\n   * decide `deprecated`.\n   */\n  _$deprecated() {\n    const tag = this._find(['@deprecated']);\n    if (tag) {\n      if (tag.tagValue) {\n        this._value.deprecated = tag.tagValue;\n      } else {\n        this._value.deprecated = true;\n      }\n    }\n  }\n\n  /**\n   * decide `experimental`.\n   */\n  _$experimental() {\n    const tag = this._find(['@experimental']);\n    if (tag) {\n      if (tag.tagValue) {\n        this._value.experimental = tag.tagValue;\n      } else {\n        this._value.experimental = true;\n      }\n    }\n  }\n\n  /**\n   * decide `since`.\n   */\n  _$since() {\n    const tag = this._find(['@since']);\n    if (tag) {\n      this._value.since = tag.tagValue;\n    }\n  }\n\n  /**\n   * decide `version`.\n   */\n  _$version() {\n    const tag = this._find(['@version']);\n    if (tag) {\n      this._value.version = tag.tagValue;\n    }\n  }\n\n  /**\n   * decide `todo`.\n   */\n  _$todo() {\n    const tags = this._findAll(['@todo']);\n    if (tags) {\n      this._value.todo = [];\n      for (const tag of tags) {\n        this._value.todo.push(tag.tagValue);\n      }\n    }\n  }\n\n  /**\n   * decide `ignore`.\n   */\n  _$ignore() {\n    const tag = this._find(['@ignore']);\n    if (tag) {\n      this._value.ignore = true;\n    }\n  }\n\n  /**\n   * decide `pseudoExport`.\n   */\n  _$pseudoExport() {\n    if (this._node.__PseudoExport__) {\n      this._value.pseudoExport = true;\n    }\n  }\n\n  /**\n   * decide `undocument` with internal tag.\n   */\n  _$undocument() {\n    const tag = this._find(['@_undocument']);\n    if (tag) {\n      this._value.undocument = true;\n    }\n  }\n\n  /**\n   * decide `unknown`.\n   */\n  _$unknown() {\n    for (const tag of this._commentTags) {\n      const methodName = tag.tagName.replace(/^[@]/, '_$');\n      if (this[methodName]) continue;\n\n      if (!this._value.unknown) this._value.unknown = [];\n      this._value.unknown.push(tag);\n    }\n  }\n\n  /**\n   * decide `param`.\n   */\n  _$param() {\n    const values = this._findAllTagValues(['@param']);\n    if (!values) return;\n\n    this._value.params = [];\n    for (const value of values) {\n      const { typeText, paramName, paramDesc } = _ParamParser2.default.parseParamValue(value);\n      if (!typeText || !paramName) {\n        _InvalidCodeLogger2.default.show(this._pathResolver.fileFullPath, this._node);\n        continue;\n      }\n      const result = _ParamParser2.default.parseParam(typeText, paramName, paramDesc);\n      this._value.params.push(result);\n    }\n  }\n\n  /**\n   * decide `return`.\n   */\n  _$return() {\n    const value = this._findTagValue(['@return', '@returns']);\n    if (!value) return;\n\n    const { typeText, paramName, paramDesc } = _ParamParser2.default.parseParamValue(value, true, false, true);\n    const result = _ParamParser2.default.parseParam(typeText, paramName, paramDesc);\n    this._value.return = result;\n  }\n\n  /**\n   * decide `property`.\n   */\n  _$property() {\n    const values = this._findAllTagValues(['@property']);\n    if (!values) return;\n\n    this._value.properties = [];\n    for (const value of values) {\n      const { typeText, paramName, paramDesc } = _ParamParser2.default.parseParamValue(value);\n      const result = _ParamParser2.default.parseParam(typeText, paramName, paramDesc);\n      this._value.properties.push(result);\n    }\n  }\n\n  /**\n   * decide `type`.\n   */\n  _$type() {\n    const value = this._findTagValue(['@type']);\n    if (!value) return;\n\n    const { typeText, paramName, paramDesc } = _ParamParser2.default.parseParamValue(value, true, false, false);\n    const result = _ParamParser2.default.parseParam(typeText, paramName, paramDesc);\n    this._value.type = result;\n  }\n\n  /**\n   * decide `abstract`.\n   */\n  _$abstract() {\n    const tag = this._find(['@abstract']);\n    if (tag) {\n      this._value.abstract = true;\n    }\n  }\n\n  /**\n   * decide `override`.\n   */\n  _$override() {\n    const tag = this._find(['@override']);\n    if (tag) {\n      this._value.override = true;\n    }\n  }\n\n  /**\n   * decide `throws`.\n   */\n  _$throws() {\n    const values = this._findAllTagValues(['@throws']);\n    if (!values) return;\n\n    this._value.throws = [];\n    for (const value of values) {\n      const { typeText, paramName, paramDesc } = _ParamParser2.default.parseParamValue(value, true, false, true);\n      const result = _ParamParser2.default.parseParam(typeText, paramName, paramDesc);\n      this._value.throws.push({\n        types: result.types,\n        description: result.description\n      });\n    }\n  }\n\n  /**\n   * decide `emits`.\n   */\n  _$emits() {\n    const values = this._findAllTagValues(['@emits']);\n    if (!values) return;\n\n    this._value.emits = [];\n    for (const value of values) {\n      const { typeText, paramName, paramDesc } = _ParamParser2.default.parseParamValue(value, true, false, true);\n      const result = _ParamParser2.default.parseParam(typeText, paramName, paramDesc);\n      this._value.emits.push({\n        types: result.types,\n        description: result.description\n      });\n    }\n  }\n\n  /**\n   * decide `listens`.\n   */\n  _$listens() {\n    const values = this._findAllTagValues(['@listens']);\n    if (!values) return;\n\n    this._value.listens = [];\n    for (const value of values) {\n      const { typeText, paramName, paramDesc } = _ParamParser2.default.parseParamValue(value, true, false, true);\n      const result = _ParamParser2.default.parseParam(typeText, paramName, paramDesc);\n      this._value.listens.push({\n        types: result.types,\n        description: result.description\n      });\n    }\n  }\n\n  /**\n   * decide `decorator`.\n   */\n  _$decorator() {\n    if (!this._node.decorators) return;\n\n    this._value.decorators = [];\n    for (const decorator of this._node.decorators) {\n      const value = {};\n      switch (decorator.expression.type) {\n        case 'Identifier':\n          value.name = decorator.expression.name;\n          value.arguments = null;\n          break;\n        case 'CallExpression':\n          value.name = decorator.expression.callee.name;\n          value.arguments = (0, _babelGenerator2.default)(decorator.expression).code.replace(/^[^(]+/, '');\n          break;\n        default:\n          throw new Error(`unknown decorator expression type: ${ decorator.expression.type }`);\n      }\n      this._value.decorators.push(value);\n    }\n  }\n\n  /**\n   * find all tags.\n   * @param {string[]} names - tag names.\n   * @returns {Tag[]|null} found tags.\n   * @private\n   */\n  _findAll(names) {\n    const results = [];\n    for (const tag of this._commentTags) {\n      if (names.includes(tag.tagName)) results.push(tag);\n    }\n\n    if (results.length) {\n      return results;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * find last tag.\n   * @param {string[]} names - tag names.\n   * @returns {Tag|null} found tag.\n   * @protected\n   */\n  _find(names) {\n    const results = this._findAll(names);\n    if (results && results.length) {\n      return results[results.length - 1];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * find all tag values.\n   * @param {string[]} names - tag names.\n   * @returns {*[]|null} found values.\n   * @private\n   */\n  _findAllTagValues(names) {\n    const tags = this._findAll(names);\n    if (!tags) return null;\n\n    const results = [];\n    for (const tag of tags) {\n      results.push(tag.tagValue);\n    }\n\n    return results;\n  }\n\n  /**\n   * find ta value.\n   * @param {string[]} names - tag names.\n   * @returns {*|null} found value.\n   * @private\n   */\n  _findTagValue(names) {\n    const tag = this._find(names);\n    if (tag) {\n      return tag.tagValue;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * resolve long name.\n   * if the name relates import path, consider import path.\n   * @param {string} name - identifier name.\n   * @returns {string} resolved name.\n   * @private\n   */\n  _resolveLongname(name) {\n    let importPath = _ASTUtil2.default.findPathInImportDeclaration(this._ast, name);\n    if (!importPath) return name;\n\n    if (importPath.charAt(0) === '.' || importPath.charAt(0) === '/') {\n      if (!_path2.default.extname(importPath)) importPath += '.js';\n\n      const resolvedPath = this._pathResolver.resolve(importPath);\n      const longname = `${ resolvedPath }~${ name }`;\n      return longname;\n    } else {\n      const longname = `${ importPath }~${ name }`;\n      return longname;\n    }\n  }\n\n  /**\n   * flatten member expression property name.\n   * if node structure is [foo [bar [baz [this] ] ] ], flatten is ``this.baz.bar.foo``\n   * @param {ASTNode} node - target member expression node.\n   * @returns {string} flatten property.\n   * @private\n   */\n  _flattenMemberExpression(node) {\n    const results = [];\n    let target = node;\n\n    while (target) {\n      if (target.type === 'ThisExpression') {\n        results.push('this');\n        break;\n      } else if (target.type === 'Identifier') {\n        results.push(target.name);\n        break;\n      } else {\n        results.push(target.property.name);\n        target = target.object;\n      }\n    }\n\n    return results.reverse().join('.');\n  }\n\n  /**\n   * find class in same file, import or external.\n   * @param {string} className - target class name.\n   * @returns {string} found class long name.\n   * @private\n   */\n  _findClassLongname(className) {\n    // find in same file.\n    for (const node of this._ast.program.body) {\n      if (!['ExportDefaultDeclaration', 'ExportNamedDeclaration'].includes(node.type)) continue;\n      if (node.declaration && node.declaration.type === 'ClassDeclaration' && node.declaration.id.name === className) {\n        return `${ this._pathResolver.filePath }~${ className }`;\n      }\n    }\n\n    // find in import.\n    const importPath = _ASTUtil2.default.findPathInImportDeclaration(this._ast, className);\n    if (importPath) return this._resolveLongname(className);\n\n    // find in external\n    return className;\n  }\n}\nexports.default = AbstractDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Parser/ParamParser.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _colorLogger = require('color-logger');\n\nvar _colorLogger2 = _interopRequireDefault(_colorLogger);\n\nvar _assert = require('assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _ASTUtil = require('../Util/ASTUtil.js');\n\nvar _ASTUtil2 = _interopRequireDefault(_ASTUtil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst logger = new _colorLogger2.default('ParamParser');\n\n/**\n * Param Type Parser class.\n */\nclass ParamParser {\n\n  /**\n   * parse param value.\n   * @param {string} value - param value.\n   * @param {boolean} [type=true] if true, contain param type.\n   * @param {boolean} [name=true] if true, contain param name.\n   * @param {boolean} [desc=true] if true, contain param description.\n   * @return {{typeText: string, paramName: string, paramDesc: string}} parsed value.\n   *\n   * @example\n   * let value = '{number} param - this is number param';\n   * let {typeText, paramName, paramDesc} = ParamParser.parseParamValue(value);\n   *\n   * let value = '{number} this is number return value';\n   * let {typeText, paramDesc} = ParamParser.parseParamValue(value, true, false, true);\n   *\n   * let value = '{number}';\n   * let {typeText} = ParamParser.parseParamValue(value, true, false, false);\n   */\n  static parseParamValue(value, type = true, name = true, desc = true) {\n    value = value.trim();\n\n    let match;\n    let typeText = null;\n    let paramName = null;\n    let paramDesc = null;\n\n    // e.g {number}\n    if (type) {\n      const reg = /^\\{([^@]*?)\\}(\\s+|$)/; // ``@`` is special char in ``{@link foo}``\n      match = value.match(reg);\n      if (match) {\n        typeText = match[1];\n        value = value.replace(reg, '');\n      } else {\n        typeText = '*';\n      }\n    }\n\n    // e.g. [p1=123]\n    if (name) {\n      if (value.charAt(0) === '[') {\n        paramName = '';\n        let counter = 0;\n        for (const c of value) {\n          paramName += c;\n          if (c === '[') counter++;\n          if (c === ']') counter--;\n          if (counter === 0) break;\n        }\n\n        if (paramName) {\n          value = value.substr(paramName.length).trim();\n        }\n      } else {\n        match = value.match(/^(\\S+)/);\n        if (match) {\n          paramName = match[1];\n          value = value.replace(/^\\S+\\s*/, '');\n        }\n      }\n    }\n\n    // e.g. this is p1 desc.\n    if (desc) {\n      match = value.match(/^\\-?\\s*((:?.|\\n)*)$/m);\n      if (match) {\n        paramDesc = match[1];\n      }\n    }\n\n    (0, _assert2.default)(typeText || paramName || paramDesc, `param is invalid. param = \"${ value }\"`);\n\n    return { typeText, paramName, paramDesc };\n  }\n\n  /**\n   * parse param text and build formatted result.\n   * @param {string} typeText - param type text.\n   * @param {string} [paramName] - param name.\n   * @param {string} [paramDesc] - param description.\n   * @returns {ParsedParam} formatted result.\n   *\n   * @example\n   * let value = '{number} param - this is number param';\n   * let {typeText, paramName, paramDesc} = ParamParser.parseParamValue(value);\n   * let result = ParamParser.parseParam(typeText, paramName, paramDesc);\n   */\n  static parseParam(typeText = null, paramName = null, paramDesc = null) {\n    const result = {};\n\n    if (typeText) {\n      // check nullable\n      if (typeText[0] === '?') {\n        result.nullable = true;\n      } else if (typeText[0] === '!') {\n        result.nullable = false;\n      } else {\n        result.nullable = null;\n      }\n      typeText = typeText.replace(/^[?!]/, '');\n\n      // check record and union\n      if (typeText[0] === '{') {\n        result.types = [typeText];\n      } else if (typeText[0] === '(') {\n        typeText = typeText.replace(/^[(]/, '').replace(/[)]$/, '');\n        result.types = typeText.split('|');\n      } else if (typeText.includes('|')) {\n        if (typeText.match(/<.*?\\|.*?>/)) {\n          // union in generics. e.g. `Array<string|number>`\n          // hack: in this case, process this type in DocBuilder#_buildTypeDocLinkHTML\n          result.types = [typeText];\n        } else if (typeText.match(/^\\.\\.\\.\\(.*?\\)/)) {\n          // union with spread. e.g. `...(string|number)`\n          // hack: in this case, process this type in DocBuilder#_buildTypeDocLinkHTML\n          result.types = [typeText];\n        } else {\n          result.types = typeText.split('|');\n        }\n      } else {\n        result.types = [typeText];\n      }\n\n      if (typeText.indexOf('...') === 0) {\n        result.spread = true;\n      } else {\n        result.spread = false;\n      }\n    } else {\n      result.types = [''];\n    }\n\n    if (result.types.some(t => !t)) {\n      throw new Error(`Empty Type found name=${ paramName } desc=${ paramDesc }`);\n    }\n\n    if (paramName) {\n      // check optional\n      if (paramName[0] === '[') {\n        result.optional = true;\n        paramName = paramName.replace(/^[\\[]/, '').replace(/[\\]]$/, '');\n      } else {\n        result.optional = false;\n      }\n\n      // check default value\n      const pair = paramName.split('=');\n      if (pair.length === 2) {\n        result.defaultValue = pair[1];\n        try {\n          const raw = JSON.parse(pair[1]);\n          result.defaultRaw = raw;\n        } catch (e) {\n          result.defaultRaw = pair[1];\n        }\n      }\n\n      result.name = pair[0].trim();\n    }\n\n    result.description = paramDesc;\n\n    return result;\n  }\n\n  /* eslint-disable complexity */\n  /* eslint-disable max-statements */\n  /**\n   * guess param type by using param default arguments.\n   * @param {Object} params - node of callable AST node.\n   * @returns {ParsedParam[]} guess param results.\n   *\n   * @example\n   * // with method\n   * let results = ParamParser.guessParams(node.value.params);\n   *\n   * // with function\n   * let results = ParamParser.guessParams(node.params);\n   */\n  static guessParams(params) {\n    const _params = [];\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const result = {};\n\n      switch (param.type) {\n        case 'Identifier':\n          // e.g. func(a){}\n          result.name = param.name;\n          result.types = ['*'];\n          break;\n\n        case 'AssignmentPattern':\n          if (param.left.type === 'Identifier') {\n            result.name = param.left.name;\n          } else if (param.left.type === 'ObjectPattern') {\n            result.name = `objectPattern${ i === 0 ? '' : i }`;\n          } else if (param.left.type === 'ArrayPattern') {\n            result.name = `arrayPattern${ i === 0 ? '' : i }`;\n          }\n\n          result.optional = true;\n\n          if (param.right.type.includes('Literal')) {\n            // e.g. func(a = 10){}\n            result.types = param.right.value === null ? ['*'] : [typeof param.right.value];\n            result.defaultRaw = param.right.value;\n            result.defaultValue = `${ result.defaultRaw }`;\n          } else if (param.right.type === 'ArrayExpression') {\n            // e.g. func(a = [123]){}\n            result.types = param.right.elements.length ? [`${ typeof param.right.elements[0].value }[]`] : ['*[]'];\n            result.defaultRaw = param.right.elements.map(elm => elm.value);\n            result.defaultValue = `${ JSON.stringify(result.defaultRaw) }`;\n          } else if (param.right.type === 'ObjectExpression') {\n            const typeMap = {};\n            for (const prop of param.left.properties || []) {\n              typeMap[prop.key.name] = '*';\n            }\n\n            // e.g. func(a = {key: 123}){}\n            const obj = {};\n            for (const prop of param.right.properties) {\n              obj[prop.key.name] = prop.value.value;\n              typeMap[prop.key.name] = typeof prop.value.value;\n            }\n\n            const types = [];\n            for (const key of Object.keys(typeMap)) {\n              types.push(`\"${ key }\": ${ typeMap[key] }`);\n            }\n\n            result.types = [`{${ types.join(', ') }}`];\n            result.defaultRaw = obj;\n            result.defaultValue = `${ JSON.stringify(result.defaultRaw) }`;\n          } else if (param.right.type === 'Identifier') {\n            // e.g. func(a = value){}\n            result.types = ['*'];\n            result.defaultRaw = param.right.name;\n            result.defaultValue = `${ param.right.name }`;\n          } else {\n            // e.g. func(a = new Foo()){}, func(a = foo()){}\n            // CallExpression, NewExpression\n            result.types = ['*'];\n          }\n          break;\n        case 'RestElement':\n          // e.g. func(...a){}\n          result.name = `${ param.argument.name }`;\n          result.types = ['...*'];\n          result.spread = true;\n          break;\n        case 'ObjectPattern':\n          {\n            const objectPattern = [];\n            const raw = {};\n            for (const property of param.properties) {\n              if (property.type === 'ObjectProperty') {\n                objectPattern.push(`\"${ property.key.name }\": *`);\n                raw[property.key.name] = null;\n              } else if (property.type === 'RestProperty') {\n                objectPattern.push(`...${ property.argument.name }: Object`);\n                raw[property.argument.name] = {};\n              }\n            }\n            result.name = `objectPattern${ i === 0 ? '' : i }`;\n            result.types = [`{${ objectPattern.join(', ') }}`];\n            result.defaultRaw = raw;\n            result.defaultValue = `${ JSON.stringify(result.defaultRaw) }`;\n            break;\n          }\n        case 'ArrayPattern':\n          {\n            // e.g. func([a, b = 10]){}\n            let arrayType = null;\n            const raw = [];\n\n            for (const element of param.elements) {\n              if (element.type === 'Identifier') {\n                raw.push('null');\n              } else if (element.type === 'AssignmentPattern') {\n                if ('value' in element.right) {\n                  if (!arrayType && element.right.value !== null) arrayType = typeof element.right.value;\n                  raw.push(JSON.stringify(element.right.value));\n                } else {\n                  raw.push('*');\n                }\n              }\n            }\n\n            if (!arrayType) arrayType = '*';\n            result.name = `arrayPattern${ i === 0 ? '' : i }`;\n            result.types = [`${ arrayType }[]`];\n            result.defaultRaw = raw;\n            result.defaultValue = `[${ raw.join(', ') }]`;\n            break;\n          }\n        default:\n          logger.w('unknown param.type', param);\n      }\n\n      _params.push(result);\n    }\n\n    return _params;\n  }\n\n  /**\n   * guess return type by using return node.\n   * @param {ASTNode} body - callable body node.\n   * @returns {ParsedParam|null}\n   */\n  static guessReturnParam(body) {\n    const result = {};\n    const guessType = this.guessType.bind(this);\n\n    _ASTUtil2.default.traverse(body, (node, parent, path) => {\n      // `return` in Function is not the body's `return`\n      if (node.type.includes('Function')) {\n        path.skip();\n        return;\n      }\n\n      if (node.type !== 'ReturnStatement') return;\n\n      if (!node.argument) return;\n\n      result.types = guessType(node.argument).types;\n    });\n\n    if (result.types) {\n      return result;\n    }\n\n    return null;\n  }\n\n  /**\n   * guess self type by using assignment node.\n   * @param {ASTNode} right - assignment right node.\n   * @returns {ParsedParam}\n   */\n  static guessType(right) {\n    if (!right) {\n      return { types: ['*'] };\n    }\n\n    if (right.type === 'TemplateLiteral') {\n      return { types: ['string'] };\n    }\n\n    if (right.type === 'NullLiteral') {\n      return { types: ['*'] };\n    }\n\n    if (right.type.includes('Literal')) {\n      return { types: [typeof right.value] };\n    }\n\n    if (right.type === 'ArrayExpression') {\n      if (right.elements.length) {\n        return { types: [`${ typeof right.elements[0].value }[]`] };\n      } else {\n        return { types: ['*[]'] };\n      }\n    }\n\n    if (right.type === 'ObjectExpression') {\n      const typeMap = {};\n      for (const prop of right.properties) {\n        switch (prop.type) {\n          case 'ObjectProperty':\n            {\n              const name = `\"${ prop.key.name || prop.key.value }\"`;\n              typeMap[name] = prop.value.value ? typeof prop.value.value : '*';\n              break;\n            }\n          case 'ObjectMethod':\n            {\n              const name = `\"${ prop.key.name || prop.key.value }\"`;\n              typeMap[name] = 'function';\n              break;\n            }\n          case 'SpreadProperty':\n            {\n              const name = `...${ prop.argument.name }`;\n              typeMap[name] = 'Object';\n              break;\n            }\n          default:\n            {\n              const name = `\"${ prop.key.name || prop.key.value }\"`;\n              typeMap[name] = '*';\n            }\n        }\n      }\n\n      const types = [];\n      for (const key of Object.keys(typeMap)) {\n        types.push(`${ key }: ${ typeMap[key] }`);\n      }\n\n      return { types: [`{${ types.join(', ') }}`] };\n    }\n\n    return { types: ['*'] };\n  }\n}\nexports.default = ParamParser;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Util/InvalidCodeLogger.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fsExtra = require('fs-extra');\n\nvar _fsExtra2 = _interopRequireDefault(_fsExtra);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * logger for invalid code which can not be parsed with ESDoc.\n */\nclass InvalidCodeLogger {\n\n  constructor() {\n    this._logs = [];\n  }\n\n  /**\n   * show log.\n   * @param {string} filePath - invalid code in this file.\n   * @param {ASTNode} [node] - fail parsing node.\n   */\n  show(filePath, node) {\n    if (!node) {\n      this.showFile(filePath);\n      return;\n    }\n\n    const lines = _fsExtra2.default.readFileSync(filePath).toString().split('\\n');\n    const targetLines = [];\n    let start;\n    const end = node.loc.start.line;\n\n    if (node.leadingComments && node.leadingComments[0]) {\n      start = node.leadingComments[0].loc.start.line;\n    } else {\n      start = Math.max(0, end - 10);\n    }\n\n    for (let i = start - 1; i < end; i++) {\n      targetLines.push(`${ i + 1 }| ${ lines[i] }`);\n    }\n\n    console.log('\u001b[31merror: could not process the following code.\u001b[32m');\n    console.log(filePath);\n    console.log(targetLines.join('\\n'));\n    console.log('\u001b[0m');\n\n    this._logs.push({ filePath: filePath, log: [start, end] });\n  }\n\n  /**\n   * show error log.\n   * @param {Error} error - target error.\n   */\n  showError(error) {\n    console.log('\u001b[31m');\n    console.log(error);\n    console.log('\u001b[0m');\n  }\n\n  /**\n   * show log.\n   * @param {string} filePath - invalid code in this file.\n   * @param {Error} error - error object.\n   */\n  showFile(filePath, error) {\n    const lines = _fsExtra2.default.readFileSync(filePath).toString().split('\\n');\n    const start = Math.max(error.loc.line - 3, 1);\n    const end = Math.min(error.loc.line + 3, lines.length);\n    const targetLines = [];\n    for (let i = start - 1; i < end; i++) {\n      targetLines.push(`${ i + 1 }| ${ lines[i] }`);\n    }\n\n    console.log('\u001b[31mwarning: could not parse the following code. if you want to use ECMAScript proposals, see https://esdoc.org/manual/usage/feature.html#ecmascript-proposal\u001b[32m');\n    console.log(filePath);\n    console.log(`${ targetLines.join('\\n') }\u001b[0m`);\n\n    this._logs.push({ filePath: filePath, log: [start, end] });\n  }\n}\n\n/**\n * singleton for {@link InvalidCodeLogger}\n */\nexports.default = new InvalidCodeLogger();","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Util/ASTNodeContainer.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass ASTNodeContainer {\n  constructor() {\n    this._docId = 0;\n    this._nodes = {};\n  }\n\n  addNode(node) {\n    this._nodes[this._docId] = node;\n    return this._docId++;\n  }\n\n  getNode(id) {\n    return this._nodes[id];\n  }\n}\n\nexports.default = new ASTNodeContainer();","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/ClassDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fsExtra = require('fs-extra');\n\nvar _fsExtra2 = _interopRequireDefault(_fsExtra);\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nvar _NamingUtil = require('../Util/NamingUtil.js');\n\nvar _NamingUtil2 = _interopRequireDefault(_NamingUtil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class from Class Declaration AST node.\n */\nclass ClassDoc extends _AbstractDoc2.default {\n  /**\n   * apply own tag.\n   * @private\n   */\n  _apply() {\n    super._apply();\n\n    this._$interface();\n    this._$extends();\n    this._$implements();\n  }\n\n  /** specify ``class`` to kind. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'class';\n  }\n\n  /** take out self name from self node */\n  _$name() {\n    super._$name();\n\n    if (this._node.id) {\n      this._value.name = this._node.id.name;\n    } else {\n      this._value.name = _NamingUtil2.default.filePathToName(this._pathResolver.filePath);\n    }\n  }\n\n  /** take out self memberof from file path. */\n  _$memberof() {\n    super._$memberof();\n    this._value.memberof = this._pathResolver.filePath;\n  }\n\n  /** for @interface */\n  _$interface() {\n    const tag = this._find(['@interface']);\n    if (tag) {\n      this._value.interface = ['', 'true', true].includes(tag.tagValue);\n    } else {\n      this._value.interface = false;\n    }\n  }\n\n  /** for @extends, does not need to use this tag. */\n  _$extends() {\n    const values = this._findAllTagValues(['@extends', '@extend']);\n    if (values) {\n      this._value.extends = [];\n      for (const value of values) {\n        const { typeText } = _ParamParser2.default.parseParamValue(value, true, false, false);\n        this._value.extends.push(typeText);\n      }\n      return;\n    }\n\n    if (this._node.superClass) {\n      const node = this._node;\n      let longnames = [];\n      const targets = [];\n\n      if (node.superClass.type === 'CallExpression') {\n        targets.push(node.superClass.callee, ...node.superClass.arguments);\n      } else {\n        targets.push(node.superClass);\n      }\n\n      for (const target of targets) {\n        /* eslint-disable default-case */\n        switch (target.type) {\n          case 'Identifier':\n            longnames.push(this._resolveLongname(target.name));\n            break;\n          case 'MemberExpression':\n            {\n              const fullIdentifier = this._flattenMemberExpression(target);\n              const rootIdentifier = fullIdentifier.split('.')[0];\n              const rootLongname = this._resolveLongname(rootIdentifier);\n              const filePath = rootLongname.replace(/~.*/, '');\n              longnames.push(`${ filePath }~${ fullIdentifier }`);\n            }\n            break;\n        }\n      }\n\n      if (node.superClass.type === 'CallExpression') {\n        // expression extends may have non-class, so filter only class by name rule.\n        longnames = longnames.filter(v => v.match(/^[A-Z]|^[$_][A-Z]/));\n\n        const filePath = this._pathResolver.fileFullPath;\n        const line = node.superClass.loc.start.line;\n        const start = node.superClass.loc.start.column;\n        const end = node.superClass.loc.end.column;\n        this._value.expressionExtends = this._readSelection(filePath, line, start, end);\n      }\n\n      if (longnames.length) this._value.extends = longnames;\n    }\n  }\n\n  /** for @implements */\n  _$implements() {\n    const values = this._findAllTagValues(['@implements', '@implement']);\n    if (!values) return;\n\n    this._value.implements = [];\n    for (const value of values) {\n      const { typeText } = _ParamParser2.default.parseParamValue(value, true, false, false);\n      this._value.implements.push(typeText);\n    }\n  }\n\n  /**\n   * read selection text in file.\n   * @param {string} filePath - target file full path.\n   * @param {number} line - line number (one origin).\n   * @param {number} startColumn - start column number (one origin).\n   * @param {number} endColumn - end column number (one origin).\n   * @returns {string} selection text\n   * @private\n   */\n  _readSelection(filePath, line, startColumn, endColumn) {\n    const code = _fsExtra2.default.readFileSync(filePath).toString();\n    const lines = code.split('\\n');\n    const selectionLine = lines[line - 1];\n    const tmp = [];\n    for (let i = startColumn; i < endColumn; i++) {\n      tmp.push(selectionLine.charAt(i));\n    }\n    return tmp.join('');\n  }\n}\nexports.default = ClassDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Util/NamingUtil.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst filePathMap = {};\n\n/**\n * Identifier Naming Util class.\n */\nclass NamingUtil {\n  /**\n   * naming with file path.\n   * @param {string} filePath - target file path.\n   * @returns {string} name\n   */\n  static filePathToName(filePath) {\n    let basename = _path2.default.basename(filePath).split('.')[0];\n    basename = basename.replace(/[^a-zA-Z0-9_$]/g, '');\n\n    filePathMap[filePath] = filePathMap[filePath] || 0;\n    const count = filePathMap[filePath];\n    if (count > 0) basename += count;\n    filePathMap[filePath]++;\n\n    return basename;\n  }\n}\nexports.default = NamingUtil;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/MethodDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nvar _babelGenerator = require('babel-generator');\n\nvar _babelGenerator2 = _interopRequireDefault(_babelGenerator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class from Method Definition AST node.\n */\nclass MethodDoc extends _AbstractDoc2.default {\n  /**\n   * apply own tag.\n   * @private\n   */\n  _apply() {\n    super._apply();\n\n    Reflect.deleteProperty(this._value, 'export');\n    Reflect.deleteProperty(this._value, 'importPath');\n    Reflect.deleteProperty(this._value, 'importStyle');\n  }\n\n  /** use kind property of self node. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = this._node.kind;\n  }\n\n  /** take out self name from self node */\n  _$name() {\n    super._$name();\n\n    if (this._node.computed) {\n      const expression = (0, _babelGenerator2.default)(this._node.key).code;\n      this._value.name = `[${ expression }]`;\n    } else {\n      this._value.name = this._node.key.name;\n    }\n  }\n\n  /** take out memberof from parent class node */\n  _$memberof() {\n    super._$memberof();\n\n    let memberof;\n    let parent = this._node.parent;\n    while (parent) {\n      if (parent.type === 'ClassDeclaration' || parent.type === 'ClassExpression') {\n        memberof = `${ this._pathResolver.filePath }~${ parent.doc.value.name }`;\n        this._value.memberof = memberof;\n        return;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  /** if @param is not exists, guess type of param by using self node. but ``get`` and ``set`` are not guessed. */\n  _$param() {\n    super._$param();\n    if (this._value.params) return;\n\n    if (['set', 'get'].includes(this._value.kind)) return;\n\n    this._value.params = _ParamParser2.default.guessParams(this._node.params);\n  }\n\n  /** if @type is not exists, guess type by using self node. only ``get`` and ``set`` are guess. */\n  _$type() {\n    super._$type();\n    if (this._value.type) return;\n\n    /* eslint-disable default-case */\n    switch (this._value.kind) {\n      case 'set':\n        this._value.type = _ParamParser2.default.guessType(this._node.right);\n        break;\n      case 'get':\n        {\n          const result = _ParamParser2.default.guessReturnParam(this._node.body);\n          if (result) this._value.type = result;\n          break;\n        }\n    }\n  }\n\n  /**\n   * if @return is not exists, guess type of return by using self node.\n   * but ``constructor``, ``get`` and ``set``are not guessed.\n   */\n  _$return() {\n    super._$return();\n    if (this._value.return) return;\n\n    if (['constructor', 'set', 'get'].includes(this._value.kind)) return;\n\n    const result = _ParamParser2.default.guessReturnParam(this._node.body);\n    if (result) {\n      this._value.return = result;\n    }\n  }\n\n  /** use generator property of self node. */\n  _$generator() {\n    super._$generator();\n\n    this._value.generator = this._node.generator;\n  }\n\n  /**\n   * use async property of self node.\n   */\n  _$async() {\n    super._$async();\n\n    this._value.async = this._node.async;\n  }\n}\nexports.default = MethodDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/ClassPropertyDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _MethodDoc = require('./MethodDoc.js');\n\nvar _MethodDoc2 = _interopRequireDefault(_MethodDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class from ClassProperty AST node.\n */\nclass ClassPropertyDoc extends _AbstractDoc2.default {\n  /**\n   * apply own tag.\n   * @private\n   */\n  _apply() {\n    super._apply();\n\n    Reflect.deleteProperty(this._value, 'export');\n    Reflect.deleteProperty(this._value, 'importPath');\n    Reflect.deleteProperty(this._value, 'importStyle');\n  }\n\n  /** specify ``member`` to kind. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'member';\n  }\n\n  /** take out self name from self node */\n  _$name() {\n    super._$name();\n    this._value.name = this._node.key.name;\n  }\n\n  /** borrow {@link MethodDoc#@_memberof} */\n  _$memberof() {\n    Reflect.apply(_MethodDoc2.default.prototype._$memberof, this, []);\n  }\n\n  /** if @type is not exists, guess type by using self node */\n  _$type() {\n    super._$type();\n    if (this._value.type) return;\n\n    this._value.type = _ParamParser2.default.guessType(this._node.value);\n  }\n}\nexports.default = ClassPropertyDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/MemberDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _MethodDoc = require('./MethodDoc.js');\n\nvar _MethodDoc2 = _interopRequireDefault(_MethodDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nvar _babelGenerator = require('babel-generator');\n\nvar _babelGenerator2 = _interopRequireDefault(_babelGenerator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class from Member Expression AST node.\n */\nclass MemberDoc extends _AbstractDoc2.default {\n  /**\n   * apply own tag.\n   * @private\n   */\n  _apply() {\n    super._apply();\n\n    Reflect.deleteProperty(this._value, 'export');\n    Reflect.deleteProperty(this._value, 'importPath');\n    Reflect.deleteProperty(this._value, 'importStyle');\n  }\n\n  /** specify ``member`` to kind. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'member';\n  }\n\n  /** use static property in class */\n  _$static() {\n    let parent = this._node.parent;\n    while (parent) {\n      if (parent.type === 'ClassMethod') {\n        this._value.static = parent.static;\n        break;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  /** take out self name from self node */\n  _$name() {\n    let name;\n    if (this._node.left.computed) {\n      const expression = (0, _babelGenerator2.default)(this._node.left.property).code.replace(/^this/, '');\n      name = `[${ expression }]`;\n    } else {\n      name = this._flattenMemberExpression(this._node.left).replace(/^this\\./, '');\n    }\n    this._value.name = name;\n  }\n\n  /** borrow {@link MethodDoc#@_memberof} */\n  _$memberof() {\n    Reflect.apply(_MethodDoc2.default.prototype._$memberof, this, []);\n  }\n\n  /** if @type is not exists, guess type by using self node */\n  _$type() {\n    super._$type();\n    if (this._value.type) return;\n\n    this._value.type = _ParamParser2.default.guessType(this._node.right);\n  }\n}\nexports.default = MemberDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/FunctionDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _babelGenerator = require('babel-generator');\n\nvar _babelGenerator2 = _interopRequireDefault(_babelGenerator);\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nvar _NamingUtil = require('../Util/NamingUtil.js');\n\nvar _NamingUtil2 = _interopRequireDefault(_NamingUtil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class from Function declaration AST node.\n */\nclass FunctionDoc extends _AbstractDoc2.default {\n  /** specify ``function`` to kind. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'function';\n  }\n\n  /** take out self name from self node */\n  _$name() {\n    super._$name();\n\n    if (this._node.id) {\n      if (this._node.id.type === 'MemberExpression') {\n        // e.g. foo[bar.baz] = function bal(){}\n        const expression = (0, _babelGenerator2.default)(this._node.id).code;\n        this._value.name = `[${ expression }]`;\n      } else {\n        this._value.name = this._node.id.name;\n      }\n    } else {\n      this._value.name = _NamingUtil2.default.filePathToName(this._pathResolver.filePath);\n    }\n  }\n\n  /** take out self name from file path */\n  _$memberof() {\n    super._$memberof();\n    this._value.memberof = this._pathResolver.filePath;\n  }\n\n  /** check generator property in self node */\n  _$generator() {\n    super._$generator();\n    this._value.generator = this._node.generator;\n  }\n\n  /**\n   * use async property of self node.\n   */\n  _$async() {\n    super._$async();\n    this._value.async = this._node.async;\n  }\n\n  /** if @param is not exists, guess type of param by using self node. */\n  _$param() {\n    super._$param();\n    if (this._value.params) return;\n\n    this._value.params = _ParamParser2.default.guessParams(this._node.params);\n  }\n\n  /** if @return is not exists, guess type of return by using self node. */\n  _$return() {\n    super._$return();\n    if (this._value.return) return;\n\n    const result = _ParamParser2.default.guessReturnParam(this._node.body);\n    if (result) {\n      this._value.return = result;\n    }\n  }\n}\nexports.default = FunctionDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/VariableDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class from Variable Declaration AST node.\n */\nclass VariableDoc extends _AbstractDoc2.default {\n  /** specify ``variable`` to kind. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'variable';\n  }\n\n  /** set name by using self node. */\n  _$name() {\n    super._$name();\n\n    const type = this._node.declarations[0].id.type;\n    switch (type) {\n      case 'Identifier':\n        this._value.name = this._node.declarations[0].id.name;\n        break;\n      case 'ObjectPattern':\n        // TODO: optimize for multi variables.\n        // e.g. export const {a, b} = obj\n        this._value.name = this._node.declarations[0].id.properties[0].key.name;\n        break;\n      case 'ArrayPattern':\n        // TODO: optimize for multi variables.\n        // e.g. export cont [a, b] = arr\n        this._value.name = this._node.declarations[0].id.elements.find(v => v).name;\n        break;\n      default:\n        throw new Error(`unknown declarations type: ${ type }`);\n    }\n  }\n\n  /** set memberof by using file path. */\n  _$memberof() {\n    super._$memberof();\n    this._value.memberof = this._pathResolver.filePath;\n  }\n\n  /** if @type is not exists, guess type by using self node. */\n  _$type() {\n    super._$type();\n    if (this._value.type) return;\n\n    if (this._node.declarations[0].init.type === 'NewExpression') {\n      const className = this._node.declarations[0].init.callee.name;\n      let longname = this._findClassLongname(className);\n      if (!longname) longname = '*';\n      this._value.type = { types: [longname] };\n    } else {\n      this._value.type = _ParamParser2.default.guessType(this._node.declarations[0].init);\n    }\n  }\n}\nexports.default = VariableDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/AssignmentDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class for Assignment AST node.\n */\nclass AssignmentDoc extends _AbstractDoc2.default {\n  /**\n   * specify ``variable`` to kind.\n   */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'variable';\n  }\n\n  /**\n   * take out self name from self node.\n   */\n  _$name() {\n    super._$name();\n    const name = this._flattenMemberExpression(this._node.left).replace(/^this\\./, '');\n    this._value.name = name;\n  }\n\n  /**\n   * take out self memberof from file path.\n   */\n  _$memberof() {\n    super._$memberof();\n    this._value.memberof = this._pathResolver.filePath;\n  }\n}\nexports.default = AssignmentDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/TypedefDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _colorLogger = require('color-logger');\n\nvar _colorLogger2 = _interopRequireDefault(_colorLogger);\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst logger = new _colorLogger2.default('TypedefDoc');\n\n/**\n * Doc class for virtual comment node of typedef.\n */\nclass TypedefDoc extends _AbstractDoc2.default {\n  /**\n   * apply own tag.\n   * @private\n   */\n  _apply() {\n    super._apply();\n\n    this._$typedef();\n\n    Reflect.deleteProperty(this._value, 'export');\n    Reflect.deleteProperty(this._value, 'importPath');\n    Reflect.deleteProperty(this._value, 'importStyle');\n  }\n\n  /** specify ``typedef`` to kind. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'typedef';\n  }\n\n  /** set name by using tag. */\n  _$name() {\n    const tags = this._findAll(['@typedef']);\n    if (!tags) {\n      logger.w('can not resolve name.');\n      return;\n    }\n\n    let name;\n    for (const tag of tags) {\n      const { paramName } = _ParamParser2.default.parseParamValue(tag.tagValue, true, true, false);\n      name = paramName;\n    }\n\n    this._value.name = name;\n  }\n\n  /** set memberof by using file path. */\n  _$memberof() {\n    super._$memberof();\n\n    let memberof;\n    let parent = this._node.parent;\n    while (parent) {\n      if (parent.type === 'ClassDeclaration') {\n        memberof = `${ this._pathResolver.filePath }~${ parent.id.name }`;\n        this._value.memberof = memberof;\n        return;\n      }\n      parent = parent.parent;\n    }\n\n    this._value.memberof = this._pathResolver.filePath;\n  }\n\n  /** for @typedef */\n  _$typedef() {\n    const value = this._findTagValue(['@typedef']);\n    if (!value) return;\n\n    const { typeText, paramName, paramDesc } = _ParamParser2.default.parseParamValue(value, true, true, false);\n    const result = _ParamParser2.default.parseParam(typeText, paramName, paramDesc);\n\n    Reflect.deleteProperty(result, 'description');\n    Reflect.deleteProperty(result, 'nullable');\n    Reflect.deleteProperty(result, 'spread');\n\n    this._value.type = result;\n  }\n}\nexports.default = TypedefDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/ExternalDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _colorLogger = require('color-logger');\n\nvar _colorLogger2 = _interopRequireDefault(_colorLogger);\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst logger = new _colorLogger2.default('ExternalDoc');\n\n/**\n * Doc Class from virtual comment node of external.\n */\nclass ExternalDoc extends _AbstractDoc2.default {\n  /**\n   * apply own tag.\n   * @private\n   */\n  _apply() {\n    super._apply();\n\n    Reflect.deleteProperty(this._value, 'export');\n    Reflect.deleteProperty(this._value, 'importPath');\n    Reflect.deleteProperty(this._value, 'importStyle');\n  }\n\n  /** specify ``external`` to kind. */\n  _$kind() {\n    super._$kind();\n    this._value.kind = 'external';\n  }\n\n  /** take out self name from tag */\n  _$name() {\n    const value = this._findTagValue(['@external']);\n    if (!value) {\n      logger.w('can not resolve name.');\n    }\n\n    this._value.name = value;\n\n    const tags = this._findAll(['@external']);\n    if (!tags) {\n      logger.w('can not resolve name.');\n      return;\n    }\n\n    let name;\n    for (const tag of tags) {\n      const { typeText, paramDesc } = _ParamParser2.default.parseParamValue(tag.tagValue, true, false, true);\n      name = typeText;\n      this._value.externalLink = paramDesc;\n    }\n\n    this._value.name = name;\n  }\n\n  /** take out self memberof from file path. */\n  _$memberof() {\n    super._$memberof();\n    this._value.memberof = this._pathResolver.filePath;\n  }\n\n  /** specify name to longname */\n  _$longname() {\n    super._$longname();\n    if (this._value.longname) return;\n    this._value.longname = this._value.name;\n  }\n\n  /** avoid unknown tag */\n  _$external() {}\n}\nexports.default = ExternalDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Factory/TestDocFactory.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assert = require('assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _CommentParser = require('../Parser/CommentParser.js');\n\nvar _CommentParser2 = _interopRequireDefault(_CommentParser);\n\nvar _TestDoc = require('../Doc/TestDoc.js');\n\nvar _TestDoc2 = _interopRequireDefault(_TestDoc);\n\nvar _TestFileDoc = require('../Doc/TestFileDoc.js');\n\nvar _TestFileDoc2 = _interopRequireDefault(_TestFileDoc);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst already = Symbol('already');\n\n/**\n * Test doc factory class.\n * @example\n * let factory = new TestDocFactory('mocha', ast, pathResolver);\n * factory.push(node, parentNode);\n * let results = factory.results;\n */\nclass TestDocFactory {\n  /**\n   * get unique id.\n   * @returns {number} unique id.\n   * @private\n   */\n  static _getUniqueId() {\n    if (!this._sequence) /** @type {number} */this._sequence = 0;\n\n    return this._sequence++;\n  }\n\n  /**\n   * @type {DocObject[]}\n   */\n  get results() {\n    return [...this._results];\n  }\n\n  /**\n   * create instance.\n   * @param {string} type - test type. now support only 'mocha'.\n   * @param {AST} ast - AST of test code.\n   * @param {PathResolver} pathResolver - path resolver of test code.\n   */\n  constructor(type, ast, pathResolver) {\n    type = type.toLowerCase();\n    (0, _assert2.default)(type === 'mocha');\n\n    /** @type {string} */\n    this._type = type;\n\n    /** @type {AST} */\n    this._ast = ast;\n\n    /** @type {PathResolver} */\n    this._pathResolver = pathResolver;\n\n    /** @type {DocObject[]} */\n    this._results = [];\n\n    // file doc\n    const doc = new _TestFileDoc2.default(ast, ast, pathResolver, []);\n    this._results.push(doc.value);\n  }\n\n  /**\n   * push node, and factory process the node.\n   * @param {ASTNode} node - target node.\n   * @param {ASTNode} parentNode - parent node of target node.\n   */\n  push(node, parentNode) {\n    if (node[already]) return;\n\n    node[already] = true;\n    Reflect.defineProperty(node, 'parent', { value: parentNode });\n\n    if (this._type === 'mocha') this._pushForMocha(node, parentNode);\n  }\n\n  /**\n   * push node as mocha test code.\n   * @param {ASTNode} node - target node.\n   * @private\n   */\n  _pushForMocha(node) {\n    if (node.type !== 'ExpressionStatement') return;\n\n    const expression = node.expression;\n    if (expression.type !== 'CallExpression') return;\n\n    if (!['describe', 'it', 'context', 'suite', 'test'].includes(expression.callee.name)) return;\n\n    expression[already] = true;\n    Reflect.defineProperty(expression, 'parent', { value: node });\n\n    let tags = [];\n    if (node.leadingComments && node.leadingComments.length) {\n      const comment = node.leadingComments[node.leadingComments.length - 1];\n      tags = _CommentParser2.default.parse(comment);\n    }\n\n    const uniqueId = this.constructor._getUniqueId();\n    expression._esdocTestId = uniqueId;\n    expression._esdocTestName = expression.callee.name + uniqueId;\n\n    const testDoc = new _TestDoc2.default(this._ast, expression, this._pathResolver, tags);\n\n    this._results.push(testDoc.value);\n  }\n}\nexports.default = TestDocFactory;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/TestDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractDoc = require('./AbstractDoc.js');\n\nvar _AbstractDoc2 = _interopRequireDefault(_AbstractDoc);\n\nvar _ParamParser = require('../Parser/ParamParser.js');\n\nvar _ParamParser2 = _interopRequireDefault(_ParamParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc Class from test code file.\n */\nclass TestDoc extends _AbstractDoc2.default {\n  /**\n   * apply own tag.\n   * @private\n   */\n  _apply() {\n    super._apply();\n\n    this._$testTarget();\n\n    Reflect.deleteProperty(this._value, 'export');\n    Reflect.deleteProperty(this._value, 'importPath');\n    Reflect.deleteProperty(this._value, 'importStyle');\n  }\n\n  /** use name property of self node. */\n  _$kind() {\n    super._$kind();\n\n    switch (this._node.callee.name) {\n      case 'suite': // fall\n      case 'context': // fall\n      case 'describe':\n        this._value.kind = 'testDescribe';\n        break;\n      case 'test': // fall\n      case 'it':\n        this._value.kind = 'testIt';\n        break;\n      default:\n        throw new Error(`unknown name. node.callee.name = ${ this._node.callee.name }`);\n    }\n  }\n\n  /** set name and testId from special esdoc property. */\n  _$name() {\n    super._$name();\n\n    this._value.name = this._node._esdocTestName;\n    this._value.testId = this._node._esdocTestId;\n  }\n\n  /** set memberof to use parent test nod and file path. */\n  _$memberof() {\n    super._$memberof();\n\n    const chain = [];\n    let parent = this._node.parent;\n    while (parent) {\n      if (parent._esdocTestName) chain.push(parent._esdocTestName);\n      parent = parent.parent;\n    }\n\n    const filePath = this._pathResolver.filePath;\n\n    if (chain.length) {\n      this._value.memberof = `${ filePath }~${ chain.reverse().join('.') }`;\n      this._value.testDepth = chain.length;\n    } else {\n      this._value.memberof = filePath;\n      this._value.testDepth = 0;\n    }\n  }\n\n  /** set describe by using test node arguments. */\n  _$desc() {\n    super._$desc();\n    if (this._value.description) return;\n\n    this._value.description = this._node.arguments[0].value;\n  }\n\n  /** for @testTarget. */\n  _$testTarget() {\n    const values = this._findAllTagValues(['@test', '@testTarget']);\n    if (!values) return;\n\n    this._value.testTargets = [];\n    for (const value of values) {\n      const { typeText } = _ParamParser2.default.parseParamValue(value, true, false, false);\n      this._value.testTargets.push(typeText);\n    }\n  }\n}\nexports.default = TestDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Doc/TestFileDoc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FileDoc = require('./FileDoc.js');\n\nvar _FileDoc2 = _interopRequireDefault(_FileDoc);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Doc class for test code file.\n */\nclass TestFileDoc extends _FileDoc2.default {\n  /** set ``testFile`` to kind. */\n  _$kind() {\n    this._value.kind = 'testFile';\n  }\n}\nexports.default = TestFileDoc;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/ESDocCLI.js":"#!/usr/bin/env node\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _minimist = require('minimist');\n\nvar _minimist2 = _interopRequireDefault(_minimist);\n\nvar _ESDoc = require('./ESDoc.js');\n\nvar _ESDoc2 = _interopRequireDefault(_ESDoc);\n\nvar _publish = require('./Publisher/publish.js');\n\nvar _publish2 = _interopRequireDefault(_publish);\n\nvar _NPMUtil = require('./Util/NPMUtil.js');\n\nvar _NPMUtil2 = _interopRequireDefault(_NPMUtil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Command Line Interface for ESDoc.\n *\n * @example\n * let cli = new ESDocCLI(process.argv);\n * cli.exec();\n */\nclass ESDocCLI {\n  /**\n   * Create instance.\n   * @param {Object} argv - this is node.js argv(``process.argv``)\n   */\n  constructor(argv) {\n    /** @type {ESDocCLIArgv} */\n    this._argv = (0, _minimist2.default)(argv.slice(2));\n\n    if (this._argv.h || this._argv.help) {\n      this._showHelp();\n      process.exit(0);\n    }\n\n    if (this._argv.v || this._argv.version) {\n      this._showVersion();\n      process.exit(0);\n    }\n  }\n\n  /**\n   * execute to generate document.\n   */\n  exec() {\n    let config;\n\n    const configPath = this._findConfigFilePath();\n    if (configPath) {\n      config = this._createConfigFromJSONFile(configPath);\n    } else {\n      config = this._createConfigFromPackageJSON();\n    }\n\n    if (config) {\n      _ESDoc2.default.generate(config, _publish2.default);\n    } else {\n      this._showHelp();\n      process.exit(1);\n    }\n  }\n\n  /**\n   * show help of ESDoc\n   * @private\n   */\n  _showHelp() {\n    console.log('Usage: esdoc [-c esdoc.json]');\n    console.log('');\n    console.log('Options:');\n    console.log('  -c', 'specify config file');\n    console.log('  -h', 'output usage information');\n    console.log('  -v', 'output the version number');\n    console.log('');\n    console.log('ESDoc finds configuration by the order:');\n    console.log('  1. `-c your-esdoc.json`');\n    console.log('  2. `.esdoc.json` in current directory');\n    console.log('  3. `.esdoc.js` in current directory');\n    console.log('  4. `esdoc` property in package.json');\n  }\n\n  /**\n   * show version of ESDoc\n   * @private\n   */\n  _showVersion() {\n    const packageObj = _NPMUtil2.default.findPackage();\n    if (packageObj) {\n      console.log(packageObj.version);\n    } else {\n      console.log('0.0.0');\n    }\n  }\n\n  /**\n   * find ESDoc config file.\n   * @returns {string|null} config file path.\n   * @private\n   */\n  _findConfigFilePath() {\n    if (this._argv.c) {\n      return this._argv.c;\n    }\n\n    try {\n      const filePath = _path2.default.resolve('./.esdoc.json');\n      _fs2.default.readFileSync(filePath);\n      return filePath;\n    } catch (e) {\n      // ignore\n    }\n\n    try {\n      const filePath = _path2.default.resolve('./.esdoc.js');\n      _fs2.default.readFileSync(filePath);\n      return filePath;\n    } catch (e) {\n      // ignore\n    }\n\n    return null;\n  }\n\n  /**\n   * create config object from config file.\n   * @param {string} configFilePath - config file path.\n   * @return {ESDocConfig} config object.\n   * @private\n   */\n  _createConfigFromJSONFile(configFilePath) {\n    configFilePath = _path2.default.resolve(configFilePath);\n    const ext = _path2.default.extname(configFilePath);\n    if (ext === '.js') {\n      /* eslint-disable global-require */\n      return require(configFilePath);\n    } else {\n      const configJSON = _fs2.default.readFileSync(configFilePath, { encode: 'utf8' });\n      const config = JSON.parse(configJSON);\n      return config;\n    }\n  }\n\n  /**\n   * create config object from package.json.\n   * @return {ESDocConfig|null} config object.\n   * @private\n   */\n  _createConfigFromPackageJSON() {\n    try {\n      const filePath = _path2.default.resolve('./package.json');\n      const packageJSON = _fs2.default.readFileSync(filePath, 'utf8').toString();\n      const packageObj = JSON.parse(packageJSON);\n      return packageObj.esdoc;\n    } catch (e) {\n      // ignore\n    }\n\n    return null;\n  }\n}\n\nexports.default = ESDocCLI; // if this file is directory executed, work as CLI.\n\nconst executedFilePath = _fs2.default.realpathSync(process.argv[1]);\nif (executedFilePath === __filename) {\n  const cli = new ESDocCLI(process.argv);\n  cli.exec();\n}","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/publish.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = publish;\n\nvar _fsExtra = require('fs-extra');\n\nvar _fsExtra2 = _interopRequireDefault(_fsExtra);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _taffydb = require('taffydb');\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _StaticFileBuilder = require('./Builder/StaticFileBuilder.js');\n\nvar _StaticFileBuilder2 = _interopRequireDefault(_StaticFileBuilder);\n\nvar _IdentifiersDocBuilder = require('./Builder/IdentifiersDocBuilder.js');\n\nvar _IdentifiersDocBuilder2 = _interopRequireDefault(_IdentifiersDocBuilder);\n\nvar _IndexDocBuilder = require('./Builder/IndexDocBuilder.js');\n\nvar _IndexDocBuilder2 = _interopRequireDefault(_IndexDocBuilder);\n\nvar _ClassDocBuilder = require('./Builder/ClassDocBuilder.js');\n\nvar _ClassDocBuilder2 = _interopRequireDefault(_ClassDocBuilder);\n\nvar _SingleDocBuilder = require('./Builder/SingleDocBuilder.js');\n\nvar _SingleDocBuilder2 = _interopRequireDefault(_SingleDocBuilder);\n\nvar _FileDocBuilder = require('./Builder/FileDocBuilder.js');\n\nvar _FileDocBuilder2 = _interopRequireDefault(_FileDocBuilder);\n\nvar _SearchIndexBuilder = require('./Builder/SearchIndexBuilder.js');\n\nvar _SearchIndexBuilder2 = _interopRequireDefault(_SearchIndexBuilder);\n\nvar _CoverageBuilder = require('./Builder/CoverageBuilder.js');\n\nvar _CoverageBuilder2 = _interopRequireDefault(_CoverageBuilder);\n\nvar _ASTDocBuilder = require('./Builder/ASTDocBuilder.js');\n\nvar _ASTDocBuilder2 = _interopRequireDefault(_ASTDocBuilder);\n\nvar _SourceDocBuilder = require('./Builder/SourceDocBuilder.js');\n\nvar _SourceDocBuilder2 = _interopRequireDefault(_SourceDocBuilder);\n\nvar _TestDocBuilder = require('./Builder/TestDocBuilder.js');\n\nvar _TestDocBuilder2 = _interopRequireDefault(_TestDocBuilder);\n\nvar _TestFileDocBuilder = require('./Builder/TestFileDocBuilder.js');\n\nvar _TestFileDocBuilder2 = _interopRequireDefault(_TestFileDocBuilder);\n\nvar _ManualDocBuilder = require('./Builder/ManualDocBuilder.js');\n\nvar _ManualDocBuilder2 = _interopRequireDefault(_ManualDocBuilder);\n\nvar _LintDocBuilder = require('./Builder/LintDocBuilder.js');\n\nvar _LintDocBuilder2 = _interopRequireDefault(_LintDocBuilder);\n\nvar _Plugin = require('../Plugin/Plugin.js');\n\nvar _Plugin2 = _interopRequireDefault(_Plugin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * publish document as HTML.\n * @param {DocObject[]} values - all doc objects.\n * @param {AST[]} asts - all ASTs.\n * @param {ESDocConfig} config - ESDoc config object.\n */\nfunction publish(values, asts, config) {\n  _iceCap2.default.debug = !!config.debug;\n\n  if (!config.includeSource) {\n    for (const value of values) {\n      if (['file', 'testFile'].includes(value.kind) && 'content' in value) {\n        value.content = '';\n      }\n    }\n  }\n\n  const dumpPath = _path2.default.resolve(config.destination, 'dump.json');\n  _fsExtra2.default.outputFileSync(dumpPath, JSON.stringify(values, null, 2));\n\n  const data = (0, _taffydb.taffy)(values);\n  let _coverage = null;\n\n  function log(text) {\n    console.log(text);\n  }\n\n  function writeHTML(html, fileName) {\n    log(`output: ${ fileName }`);\n    html = _Plugin2.default.onHandleHTML(html, fileName);\n    const filePath = _path2.default.resolve(config.destination, fileName);\n    _fsExtra2.default.outputFileSync(filePath, html, { encoding: 'utf8' });\n  }\n\n  function writeCoverage(coverage, fileName) {\n    _coverage = coverage;\n    const json = JSON.stringify(coverage, null, 2);\n    const filePath = _path2.default.resolve(config.destination, fileName);\n    _fsExtra2.default.outputFileSync(filePath, json, { encoding: 'utf8' });\n  }\n\n  function writeBadge(badge, fileName) {\n    log(`output: ${ fileName }`);\n    const filePath = _path2.default.resolve(config.destination, fileName);\n    _fsExtra2.default.outputFileSync(filePath, badge, { encoding: 'utf8' });\n  }\n\n  function writeAST(astJSON, fileName) {\n    const filePath = _path2.default.resolve(config.destination, fileName);\n    _fsExtra2.default.outputFileSync(filePath, astJSON, { encoding: 'utf8' });\n  }\n\n  function copy(srcPath, destPath) {\n    log(`output: ${ destPath }`);\n    _fsExtra2.default.copySync(srcPath, _path2.default.resolve(config.destination, destPath));\n  }\n\n  if (config.coverage) {\n    new _CoverageBuilder2.default(data, config).exec(writeCoverage, writeBadge);\n  }\n\n  new _IdentifiersDocBuilder2.default(data, config).exec(writeHTML);\n  new _IndexDocBuilder2.default(data, config, _coverage).exec(writeHTML);\n  new _ClassDocBuilder2.default(data, config).exec(writeHTML);\n  new _SingleDocBuilder2.default(data, config).exec(writeHTML);\n  new _FileDocBuilder2.default(data, config).exec(writeHTML);\n  new _StaticFileBuilder2.default(data, config).exec(copy);\n  new _SearchIndexBuilder2.default(data, config).exec(writeHTML);\n  new _ASTDocBuilder2.default(data, asts, config).exec(writeAST);\n  new _SourceDocBuilder2.default(data, config, _coverage).exec(writeHTML);\n  new _ManualDocBuilder2.default(data, config).exec(writeHTML, copy, writeBadge);\n\n  // package.json\n  try {\n    const json = _fsExtra2.default.readFileSync(config.package, { encoding: 'utf-8' });\n    const filePath = _path2.default.resolve(config.destination, 'package.json');\n    _fsExtra2.default.outputFileSync(filePath, json, { encoding: 'utf8' });\n  } catch (e) {\n    // ignore\n  }\n\n  if (config.test) {\n    new _TestDocBuilder2.default(data, config).exec(writeHTML);\n    new _TestFileDocBuilder2.default(data, config).exec(writeHTML);\n  }\n\n  if (config.coverage) {\n    console.log('==================================');\n    console.log(`Coverage: ${ _coverage.coverage } (${ _coverage.actualCount }/${ _coverage.expectCount })`);\n    console.log('==================================');\n  }\n\n  if (config.lint) {\n    new _LintDocBuilder2.default(data, config).exec();\n  }\n}","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/StaticFileBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Static file output builder class.\n */\nclass StaticFileBuilder extends _DocBuilder2.default {\n  /**\n   * execute build output.\n   * @param {function(content: string, filePath: string)} callback - is called with each output.\n   */\n  exec(callback) {\n    callback(_path2.default.resolve(__dirname, './template/css'), './css');\n    callback(_path2.default.resolve(__dirname, './template/script'), './script');\n    callback(_path2.default.resolve(__dirname, './template/image'), './image');\n\n    // see DocBuilder#_buildLayoutDoc\n    const scripts = this._config.scripts || [];\n    for (let i = 0; i < scripts.length; i++) {\n      const userScript = scripts[i];\n      const name = `./user/script/${ i }-${ _path2.default.basename(userScript) }`;\n      callback(userScript, name);\n    }\n\n    const styles = this._config.styles || [];\n    for (let i = 0; i < styles.length; i++) {\n      const userStyle = styles[i];\n      const name = `./user/css/${ i }-${ _path2.default.basename(userStyle) }`;\n      callback(userStyle, name);\n    }\n  }\n}\nexports.default = StaticFileBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/DocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _escapeHtml = require('escape-html');\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _util = require('./util.js');\n\nvar _DocResolver = require('./DocResolver.js');\n\nvar _DocResolver2 = _interopRequireDefault(_DocResolver);\n\nvar _NPMUtil = require('../../Util/NPMUtil.js');\n\nvar _NPMUtil2 = _interopRequireDefault(_NPMUtil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Builder base class.\n */\nclass DocBuilder {\n  /**\n   * create instance.\n   * @param {Taffy} data - doc object database.\n   * @param {ESDocConfig} config - esdoc config is used build output.\n   */\n  constructor(data, config) {\n    this._data = data;\n    this._config = config;\n    new _DocResolver2.default(this).resolve();\n  }\n\n  /* eslint-disable no-unused-vars */\n  /**\n   * execute building output.\n   * @abstract\n   * @param {function} callback - is called with some data.\n   */\n  exec(callback) {}\n\n  /**\n   * find doc object.\n   * @param {...Object} cond - find condition.\n   * @returns {DocObject[]} found doc objects.\n   * @private\n   */\n  _find(...cond) {\n    return this._orderedFind(null, ...cond);\n  }\n\n  /**\n   * find all identifiers with kind grouping.\n   * @returns {{class: DocObject[], interface: DocObject[], function: DocObject[], variable: DocObject[], typedef: DocObject[], external: DocObject[]}} found doc objects.\n   * @private\n   */\n  _findAllIdentifiersKindGrouping() {\n    const result = {\n      class: this._find([{ kind: 'class', interface: false }]),\n      interface: this._find([{ kind: 'class', interface: true }]),\n      function: this._find([{ kind: 'function' }]),\n      variable: this._find([{ kind: 'variable' }]),\n      typedef: this._find([{ kind: 'typedef' }]),\n      external: this._find([{ kind: 'external' }]).filter(v => !v.builtinExternal)\n    };\n    return result;\n  }\n\n  /**\n   * fuzzy find doc object by name.\n   * - equal with longname\n   * - equal with name\n   * - include in longname\n   * - include in ancestor\n   *\n   * @param {string} name - target identifier name.\n   * @param {string} [kind] - target kind.\n   * @returns {DocObject[]} found doc objects.\n   * @private\n   */\n  _findByName(name, kind = null) {\n    let docs;\n\n    if (kind) {\n      docs = this._orderedFind(null, { longname: name, kind: kind });\n    } else {\n      docs = this._orderedFind(null, { longname: name });\n    }\n    if (docs.length) return docs;\n\n    if (kind) {\n      docs = this._orderedFind(null, { name: name, kind: kind });\n    } else {\n      docs = this._orderedFind(null, { name: name });\n    }\n    if (docs.length) return docs;\n\n    const regexp = new RegExp(`[~]${ name.replace('*', '\\\\*') }$`); // if name is `*`, need to escape.\n    if (kind) {\n      docs = this._orderedFind(null, { longname: { regex: regexp }, kind: kind });\n    } else {\n      docs = this._orderedFind(null, { longname: { regex: regexp } });\n    }\n    if (docs.length) return docs;\n\n    // inherited method?\n    const matched = name.match(/(.*)[.#](.*)$/); // instance method(Foo#bar) or static method(Foo.baz)\n    if (matched) {\n      const parent = matched[1];\n      const childName = matched[2];\n      const parentDoc = this._findByName(parent, 'class')[0];\n      if (parentDoc && parentDoc._custom_extends_chains) {\n        for (const superLongname of parentDoc._custom_extends_chains) {\n          const docs = this._find({ memberof: superLongname, name: childName });\n          if (docs.length) return docs;\n        }\n      }\n    }\n\n    return [];\n  }\n\n  /**\n   * find doc objects that is ordered.\n   * @param {string} order - doc objects order(``column asec`` or ``column desc``).\n   * @param {...Object} cond - condition objects\n   * @returns {DocObject[]} found doc objects.\n   * @private\n   */\n  _orderedFind(order, ...cond) {\n    const data = this._data(...cond);\n\n    if (order) {\n      return data.order(`${ order }, name asec`).map(v => v);\n    } else {\n      return data.order('name asec').map(v => v);\n    }\n  }\n\n  /**\n   * read html template.\n   * @param {string} fileName - template file name.\n   * @return {string} html of template.\n   * @protected\n   */\n  _readTemplate(fileName) {\n    const filePath = _path2.default.resolve(__dirname, `./template/${ fileName }`);\n    return _fs2.default.readFileSync(filePath, { encoding: 'utf-8' });\n  }\n\n  /**\n   * get target's essential info.\n   * @returns {{title: string, version: string, url: string}}\n   * @private\n   */\n  _getInfo() {\n    const config = this._config;\n    let packageObj = {};\n    if (config.package) {\n      const packagePath = config.package;\n      try {\n        const json = _fs2.default.readFileSync(packagePath, { encoding: 'utf-8' });\n        packageObj = JSON.parse(json);\n      } catch (e) {\n        // ignore\n      }\n    }\n\n    // repository url\n    let url = null;\n    if (packageObj.repository) {\n      if (packageObj.repository.url) {\n        url = packageObj.repository.url;\n      } else {\n        url = packageObj.repository;\n      }\n\n      if (typeof url === 'string') {\n        if (url.indexOf('git@github.com:') === 0) {\n          // url: git@github.com:foo/bar.git\n          const matched = url.match(/^git@github\\.com:(.*)\\.git$/);\n          if (matched && matched[1]) {\n            url = `https://github.com/${ matched[1] }`;\n          }\n        } else if (url.match(/^[\\w\\d\\-_]+\\/[\\w\\d\\-_]+$/)) {\n          // url: foo/bar\n          url = `https://github.com/${ url }`;\n        } else if (url.match(/^git\\+https:\\/\\/github.com\\/.*\\.git$/)) {\n          // git+https://github.com/foo/bar.git\n          const matched = url.match(/^git\\+(https:\\/\\/github.com\\/.*)\\.git$/);\n          url = matched[1];\n        } else if (url.match(/(https?:\\/\\/.*$)/)) {\n          // other url\n          const matched = url.match(/(https?:\\/\\/.*$)/);\n          url = matched[1];\n        } else {\n          url = '';\n        }\n      } else {\n        url = null;\n      }\n    }\n\n    const indexInfo = {\n      title: config.title || packageObj.name,\n      version: config.version || packageObj.version,\n      url: url\n    };\n\n    return indexInfo;\n  }\n\n  /**\n   * build common layout output.\n   * @return {IceCap} layout output.\n   * @private\n   */\n  _buildLayoutDoc() {\n    const info = this._getInfo();\n\n    const ice = new _iceCap2.default(this._readTemplate('layout.html'), { autoClose: false });\n\n    const packageObj = _NPMUtil2.default.findPackage();\n    if (packageObj) {\n      ice.text('esdocVersion', `(${ packageObj.version })`);\n    } else {\n      ice.drop('esdocVersion');\n    }\n\n    if (info.url) {\n      ice.attr('repoURL', 'href', info.url);\n      if (info.url.match(new RegExp('^https?://github.com/'))) {\n        ice.attr('repoURL', 'class', 'repo-url-github');\n      }\n    } else {\n      ice.drop('repoURL');\n    }\n\n    ice.drop('testLink', !this._config.test);\n\n    // see StaticFileBuilder#exec\n    ice.loop('userScript', this._config.scripts || [], (i, userScript, ice) => {\n      const name = `user/script/${ i }-${ _path2.default.basename(userScript) }`;\n      ice.attr('userScript', 'src', name);\n    });\n\n    ice.loop('userStyle', this._config.styles || [], (i, userStyle, ice) => {\n      const name = `user/css/${ i }-${ _path2.default.basename(userStyle) }`;\n      ice.attr('userStyle', 'href', name);\n    });\n\n    ice.drop('manualHeaderLink', !this._config.manual);\n\n    if (this._config.manual && this._config.manual.globalIndex) {\n      ice.drop('manualHeaderLink');\n    }\n\n    ice.load('nav', this._buildNavDoc());\n    return ice;\n  }\n\n  /**\n   * build common navigation output.\n   * @return {IceCap} navigation output.\n   * @private\n   */\n  _buildNavDoc() {\n    const html = this._readTemplate('nav.html');\n    const ice = new _iceCap2.default(html);\n\n    const kinds = ['class', 'function', 'variable', 'typedef', 'external'];\n    const allDocs = this._find({ kind: kinds }).filter(v => !v.builtinExternal);\n    const kindOrder = { class: 0, interface: 1, function: 2, variable: 3, typedef: 4, external: 5 };\n    allDocs.sort((a, b) => {\n      const filePathA = a.longname.split('~')[0];\n      const filePathB = b.longname.split('~')[0];\n      const dirPathA = _path2.default.dirname(filePathA);\n      const dirPathB = _path2.default.dirname(filePathB);\n      const kindA = a.interface ? 'interface' : a.kind;\n      const kindB = b.interface ? 'interface' : b.kind;\n      if (dirPathA === dirPathB) {\n        if (kindA === kindB) {\n          return a.longname > b.longname ? 1 : -1;\n        } else {\n          return kindOrder[kindA] > kindOrder[kindB] ? 1 : -1;\n        }\n      } else {\n        return dirPathA > dirPathB ? 1 : -1;\n      }\n    });\n    let lastDirPath = '.';\n    ice.loop('doc', allDocs, (i, doc, ice) => {\n      const filePath = doc.longname.split('~')[0].replace(/^.*?[/]/, '');\n      const dirPath = _path2.default.dirname(filePath);\n      const kind = doc.interface ? 'interface' : doc.kind;\n      const kindText = kind.charAt(0).toUpperCase();\n      const kindClass = `kind-${ kind }`;\n      ice.load('name', this._buildDocLinkHTML(doc.longname));\n      ice.load('kind', kindText);\n      ice.attr('kind', 'class', kindClass);\n      ice.text('dirPath', dirPath);\n      ice.drop('dirPath', lastDirPath === dirPath);\n      lastDirPath = dirPath;\n    });\n\n    return ice;\n  }\n\n  /**\n   * find doc object for each access.\n   * @param {DocObject} doc - parent doc object.\n   * @param {string} kind - kind property condition.\n   * @param {boolean} isStatic - static property condition\n   * @returns {Array[]} found doc objects.\n   * @property {Array[]} 0 - ['Public', DocObject[]]\n   * @property {Array[]} 1 - ['Protected', DocObject[]]\n   * @property {Array[]} 2 - ['Private', DocObject[]]\n   * @private\n   */\n  _findAccessDocs(doc, kind, isStatic = true) {\n    const cond = { kind: kind, static: isStatic };\n\n    if (doc) cond.memberof = doc.longname;\n\n    /* eslint-disable default-case */\n    switch (kind) {\n      case 'class':\n        cond.interface = false;\n        break;\n      case 'interface':\n        cond.kind = 'class';\n        cond.interface = true;\n        break;\n      case 'member':\n        cond.kind = ['member', 'get', 'set'];\n        break;\n    }\n\n    const publicDocs = this._find(cond, { access: 'public' }).filter(v => !v.builtinExternal);\n    const protectedDocs = this._find(cond, { access: 'protected' }).filter(v => !v.builtinExternal);\n    const privateDocs = this._find(cond, { access: 'private' }).filter(v => !v.builtinExternal);\n    const accessDocs = [['Public', publicDocs], ['Protected', protectedDocs], ['Private', privateDocs]];\n\n    return accessDocs;\n  }\n\n  /**\n   * build summary output html by parent doc.\n   * @param {DocObject} doc - parent doc object.\n   * @param {string} kind - target kind property.\n   * @param {string} title - summary title.\n   * @param {boolean} [isStatic=true] - target static property.\n   * @returns {string} html of summary.\n   * @private\n   */\n  _buildSummaryHTML(doc, kind, title, isStatic = true) {\n    const accessDocs = this._findAccessDocs(doc, kind, isStatic);\n    let html = '';\n    for (const accessDoc of accessDocs) {\n      const docs = accessDoc[1];\n      if (!docs.length) continue;\n\n      let prefix = '';\n      if (docs[0].static) prefix = 'Static ';\n      const _title = `${ prefix }${ accessDoc[0] } ${ title }`;\n\n      const result = this._buildSummaryDoc(docs, _title);\n      if (result) {\n        html += result.html;\n      }\n    }\n\n    return html;\n  }\n\n  /**\n   * build summary output html by docs.\n   * @param {DocObject[]} docs - target docs.\n   * @param {string} title - summary title.\n   * @param {boolean} innerLink - if true, link in summary is inner link.\n   * @return {IceCap} summary output.\n   * @private\n   */\n  _buildSummaryDoc(docs, title, innerLink) {\n    if (docs.length === 0) return null;\n\n    const ice = new _iceCap2.default(this._readTemplate('summary.html'));\n\n    ice.text('title', title);\n    ice.loop('target', docs, (i, doc, ice) => {\n      ice.text('generator', doc.generator ? '*' : '');\n      ice.text('async', doc.async ? 'async' : '');\n      ice.load('name', this._buildDocLinkHTML(doc.longname, null, innerLink, doc.kind));\n      ice.load('signature', this._buildSignatureHTML(doc));\n      ice.load('description', (0, _util.shorten)(doc, true));\n      ice.text('abstract', doc.abstract ? 'abstract' : '');\n      ice.text('access', doc.access);\n      if (['get', 'set'].includes(doc.kind)) {\n        ice.text('kind', doc.kind);\n      } else {\n        ice.drop('kind');\n      }\n\n      if (['member', 'method', 'get', 'set'].includes(doc.kind)) {\n        ice.text('static', doc.static ? 'static' : '');\n      } else {\n        ice.drop('static');\n      }\n\n      ice.text('since', doc.since);\n      ice.load('deprecated', this._buildDeprecatedHTML(doc));\n      ice.load('experimental', this._buildExperimentalHTML(doc));\n      ice.text('version', doc.version);\n    });\n\n    return ice;\n  }\n\n  /**\n   * build detail output html by parent doc.\n   * @param {DocObject} doc - parent doc object.\n   * @param {string} kind - target kind property.\n   * @param {string} title - detail title.\n   * @param {boolean} [isStatic=true] - target static property.\n   * @returns {string} html of detail.\n   * @private\n   */\n  _buildDetailHTML(doc, kind, title, isStatic = true) {\n    const accessDocs = this._findAccessDocs(doc, kind, isStatic);\n    let html = '';\n    for (const accessDoc of accessDocs) {\n      const docs = accessDoc[1];\n      if (!docs.length) continue;\n\n      let prefix = '';\n      if (docs[0].static) prefix = 'Static ';\n      const _title = `${ prefix }${ accessDoc[0] } ${ title }`;\n\n      const result = this._buildDetailDocs(docs, _title);\n      if (result) html += result.html;\n    }\n\n    return html;\n  }\n\n  /* eslint-disable max-statements */\n  /**\n   * build detail output html by docs.\n   * @param {DocObject[]} docs - target docs.\n   * @param {string} title - detail title.\n   * @return {IceCap} detail output.\n   * @private\n   */\n  _buildDetailDocs(docs, title) {\n    const ice = new _iceCap2.default(this._readTemplate('details.html'));\n\n    ice.text('title', title);\n    ice.drop('title', !docs.length);\n\n    ice.loop('detail', docs, (i, doc, ice) => {\n      const scope = doc.static ? 'static' : 'instance';\n      ice.attr('anchor', 'id', `${ scope }-${ doc.kind }-${ doc.name }`);\n      ice.text('generator', doc.generator ? '*' : '');\n      ice.text('async', doc.async ? 'async' : '');\n      ice.text('name', doc.name);\n      ice.load('signature', this._buildSignatureHTML(doc));\n      ice.load('description', doc.description || this._buildOverrideMethodDescription(doc));\n      ice.text('abstract', doc.abstract ? 'abstract' : '');\n      ice.text('access', doc.access);\n      if (['get', 'set'].includes(doc.kind)) {\n        ice.text('kind', doc.kind);\n      } else {\n        ice.drop('kind');\n      }\n      if (doc.export && doc.importPath && doc.importStyle) {\n        const link = this._buildFileDocLinkHTML(doc, doc.importPath);\n        ice.into('importPath', `import ${ doc.importStyle } from '${ link }'`, (code, ice) => {\n          ice.load('importPathCode', code);\n        });\n      } else {\n        ice.drop('importPath');\n      }\n\n      if (['member', 'method', 'get', 'set'].includes(doc.kind)) {\n        ice.text('static', doc.static ? 'static' : '');\n      } else {\n        ice.drop('static');\n      }\n\n      ice.load('source', this._buildFileDocLinkHTML(doc, 'source'));\n      ice.text('since', doc.since, 'append');\n      ice.load('deprecated', this._buildDeprecatedHTML(doc));\n      ice.load('experimental', this._buildExperimentalHTML(doc));\n      ice.text('version', doc.version, 'append');\n      ice.load('see', this._buildDocsLinkHTML(doc.see), 'append');\n      ice.load('todo', this._buildDocsLinkHTML(doc.todo), 'append');\n      ice.load('override', this._buildOverrideMethod(doc));\n      ice.load('decorator', this._buildDecoratorHTML(doc), 'append');\n\n      let isFunction = false;\n      if (['method', 'constructor', 'function'].indexOf(doc.kind) !== -1) isFunction = true;\n      if (doc.kind === 'typedef' && doc.params && doc.type.types[0] === 'function') isFunction = true;\n\n      if (isFunction) {\n        ice.load('properties', this._buildProperties(doc.params, 'Params:'));\n      } else {\n        ice.load('properties', this._buildProperties(doc.properties, 'Properties:'));\n      }\n\n      // return\n      if (doc.return) {\n        ice.load('returnDescription', doc.return.description);\n        const typeNames = [];\n        for (const typeName of doc.return.types) {\n          typeNames.push(this._buildTypeDocLinkHTML(typeName));\n        }\n        if (typeof doc.return.nullable === 'boolean') {\n          const nullable = doc.return.nullable;\n          ice.load('returnType', `${ typeNames.join(' | ') } (nullable: ${ nullable })`);\n        } else {\n          ice.load('returnType', typeNames.join(' | '));\n        }\n\n        ice.load('returnProperties', this._buildProperties(doc.properties, 'Return Properties:'));\n      } else {\n        ice.drop('returnParams');\n      }\n\n      // throws\n      if (doc.throws) {\n        ice.loop('throw', doc.throws, (i, exceptionDoc, ice) => {\n          ice.load('throwName', this._buildDocLinkHTML(exceptionDoc.types[0]));\n          ice.load('throwDesc', exceptionDoc.description);\n        });\n      } else {\n        ice.drop('throwWrap');\n      }\n\n      // fires\n      if (doc.emits) {\n        ice.loop('emit', doc.emits, (i, emitDoc, ice) => {\n          ice.load('emitName', this._buildDocLinkHTML(emitDoc.types[0]));\n          ice.load('emitDesc', emitDoc.description);\n        });\n      } else {\n        ice.drop('emitWrap');\n      }\n\n      // listens\n      if (doc.listens) {\n        ice.loop('listen', doc.listens, (i, listenDoc, ice) => {\n          ice.load('listenName', this._buildDocLinkHTML(listenDoc.types[0]));\n          ice.load('listenDesc', listenDoc.description);\n        });\n      } else {\n        ice.drop('listenWrap');\n      }\n\n      // example\n      ice.into('example', doc.examples, (examples, ice) => {\n        ice.loop('exampleDoc', examples, (i, exampleDoc, ice) => {\n          const parsed = (0, _util.parseExample)(exampleDoc);\n          ice.text('exampleCode', parsed.body);\n          ice.text('exampleCaption', parsed.caption);\n        });\n      });\n\n      // tests\n      ice.into('tests', doc._custom_tests, (tests, ice) => {\n        ice.loop('test', tests, (i, test, ice) => {\n          const testDoc = this._find({ longname: test })[0];\n          ice.load('test', this._buildFileDocLinkHTML(testDoc, testDoc.testFullDescription));\n        });\n      });\n    });\n\n    return ice;\n  }\n\n  /**\n   * get output html page title. use ``title`` in {@link ESDocConfig}.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} page title.\n   * @private\n   */\n  _getTitle(doc = '') {\n    const name = doc.name || doc.toString();\n\n    if (!name) {\n      if (this._config.title) {\n        return `${ this._config.title } API Document`;\n      } else {\n        return 'API Document';\n      }\n    }\n\n    if (this._config.title) {\n      return `${ name } | ${ this._config.title } API Document`;\n    } else {\n      return `${ name } | API Document`;\n    }\n  }\n\n  /**\n   * get base url html page. it is used html base tag.\n   * @param {string} fileName - output file path.\n   * @returns {string} base url.\n   * @protected\n   */\n  _getBaseUrl(fileName) {\n    const baseUrl = '../'.repeat(fileName.split('/').length - 1);\n    return baseUrl;\n  }\n\n  /**\n   * gat url of output html page.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} url of output html. it is relative path from output root dir.\n   * @private\n   */\n  _getURL(doc) {\n    let inner = false;\n    if (['variable', 'function', 'member', 'typedef', 'method', 'constructor', 'get', 'set'].includes(doc.kind)) {\n      inner = true;\n    }\n\n    if (inner) {\n      const scope = doc.static ? 'static' : 'instance';\n      const fileName = this._getOutputFileName(doc);\n      return `${ fileName }#${ scope }-${ doc.kind }-${ doc.name }`;\n    } else {\n      const fileName = this._getOutputFileName(doc);\n      return fileName;\n    }\n  }\n\n  /**\n   * get file name of output html page.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} file name.\n   * @private\n   */\n  _getOutputFileName(doc) {\n    switch (doc.kind) {\n      case 'variable':\n        return 'variable/index.html';\n      case 'function':\n        return 'function/index.html';\n      case 'member': // fall\n      case 'method': // fall\n      case 'constructor': // fall\n      case 'set': // fall\n      case 'get':\n        {\n          // fal\n          const parentDoc = this._find({ longname: doc.memberof })[0];\n          return this._getOutputFileName(parentDoc);\n        }\n      case 'external':\n        return 'external/index.html';\n      case 'typedef':\n        return 'typedef/index.html';\n      case 'class':\n        return `class/${ doc.longname }.html`;\n      case 'file':\n        return `file/${ doc.longname }.html`;\n      case 'testFile':\n        return `test-file/${ doc.longname }.html`;\n      case 'testDescribe':\n        return 'test.html';\n      case 'testIt':\n        return 'test.html';\n      default:\n        throw new Error('DocBuilder: can not resolve file name.');\n    }\n  }\n\n  /**\n   * build html link to file page.\n   * @param {DocObject} doc - target doc object.\n   * @param {string} text - link text.\n   * @returns {string} html of link.\n   * @private\n   */\n  _buildFileDocLinkHTML(doc, text = null) {\n    if (!doc) return '';\n\n    let fileDoc;\n    if (doc.kind === 'file' || doc.kind === 'testFile') {\n      fileDoc = doc;\n    } else {\n      const filePath = doc.longname.split('~')[0];\n      fileDoc = this._find({ kind: ['file', 'testFile'], longname: filePath })[0];\n    }\n\n    if (!fileDoc) return '';\n\n    if (!text) text = fileDoc.name;\n\n    if (doc.kind === 'file' || doc.kind === 'testFile') {\n      return `<span><a href=\"${ this._getURL(fileDoc) }\">${ text }</a></span>`;\n    } else {\n      return `<span><a href=\"${ this._getURL(fileDoc) }#lineNumber${ doc.lineNumber }\">${ text }</a></span>`;\n    }\n  }\n\n  /**\n   * build html link of type.\n   * @param {string} typeName - type name(e.g. ``number[]``, ``Map<number, string>``)\n   * @returns {string} html of link.\n   * @private\n   * @todo re-implement with parser combinator.\n   */\n  _buildTypeDocLinkHTML(typeName) {\n    // e.g. number[]\n    let matched = typeName.match(/^(.*?)\\[\\]$/);\n    if (matched) {\n      typeName = matched[1];\n      return `<span>${ this._buildDocLinkHTML(typeName, typeName) }<span>[]</span></span>`;\n    }\n\n    // e.g. function(a: number, b: string): boolean\n    matched = typeName.match(/function *\\((.*?)\\)(.*)/);\n    if (matched) {\n      const functionLink = this._buildDocLinkHTML('function');\n      if (!matched[1] && !matched[2]) return `<span>${ functionLink }<span>()</span></span>`;\n\n      let innerTypes = [];\n      if (matched[1]) {\n        // bad hack: Map.<string, boolean> => Map.<string\\Z boolean>\n        // bad hack: {a: string, b: boolean} => {a\\Y string\\Z b\\Y boolean}\n        const inner = matched[1].replace(/<.*?>/g, a => a.replace(/,/g, '\\\\Z')).replace(/{.*?}/g, a => a.replace(/,/g, '\\\\Z').replace(/:/g, '\\\\Y'));\n        innerTypes = inner.split(',').map(v => {\n          const tmp = v.split(':').map(v => v.trim());\n          if (tmp.length !== 2) throw new SyntaxError(`Invalid function type annotation: \\`${ matched[0] }\\``);\n\n          const paramName = tmp[0];\n          const typeName = tmp[1].replace(/\\\\Z/g, ',').replace(/\\\\Y/g, ':');\n          return `${ paramName }: ${ this._buildTypeDocLinkHTML(typeName) }`;\n        });\n      }\n\n      let returnType = '';\n      if (matched[2]) {\n        const type = matched[2].split(':')[1];\n        if (type) returnType = `: ${ this._buildTypeDocLinkHTML(type.trim()) }`;\n      }\n\n      return `<span>${ functionLink }<span>(${ innerTypes.join(', ') })</span>${ returnType }</span>`;\n    }\n\n    // e.g. {a: number, b: string}\n    matched = typeName.match(/^\\{(.*?)\\}$/);\n    if (matched) {\n      if (!matched[1]) return '{}';\n\n      // bad hack: Map.<string, boolean> => Map.<string\\Z boolean>\n      // bad hack: {a: string, b: boolean} => {a\\Y string\\Z b\\Y boolean}\n      const inner = matched[1].replace(/<.*?>/g, a => a.replace(/,/g, '\\\\Z')).replace(/{.*?}/g, a => a.replace(/,/g, '\\\\Z').replace(/:/g, '\\\\Y'));\n      const innerTypes = inner.split(',').map(v => {\n        const tmp = v.split(':').map(v => v.trim());\n        const paramName = tmp[0];\n        let typeName = tmp[1].replace(/\\\\Z/g, ',').replace(/\\\\Y/g, ':');\n        if (typeName.includes('|')) {\n          typeName = typeName.replace(/^\\(/, '').replace(/\\)$/, '');\n          const typeNames = typeName.split('|').map(v => v.trim());\n          const html = [];\n          for (const unionType of typeNames) {\n            html.push(this._buildTypeDocLinkHTML(unionType));\n          }\n          return `${ paramName }: ${ html.join('|') }`;\n        } else {\n          return `${ paramName }: ${ this._buildTypeDocLinkHTML(typeName) }`;\n        }\n      });\n\n      return `{${ innerTypes.join(', ') }}`;\n    }\n\n    // e.g. Map<number, string>\n    matched = typeName.match(/^(.*?)\\.?<(.*?)>$/);\n    if (matched) {\n      const mainType = matched[1];\n      // bad hack: Map.<string, boolean> => Map.<string\\Z boolean>\n      // bad hack: {a: string, b: boolean} => {a\\Y string\\Z b\\Y boolean}\n      const inner = matched[2].replace(/<.*?>/g, a => a.replace(/,/g, '\\\\Z')).replace(/{.*?}/g, a => a.replace(/,/g, '\\\\Z').replace(/:/g, '\\\\Y'));\n      const innerTypes = inner.split(',').map(v => {\n        return v.split('|').map(vv => {\n          vv = vv.trim().replace(/\\\\Z/g, ',').replace(/\\\\Y/g, ':');\n          return this._buildTypeDocLinkHTML(vv);\n        }).join('|');\n      });\n\n      const html = `${ this._buildDocLinkHTML(mainType, mainType) }<${ innerTypes.join(', ') }>`;\n      return html;\n    }\n\n    if (typeName.indexOf('...') === 0) {\n      typeName = typeName.replace('...', '');\n      if (typeName.includes('|')) {\n        const typeNames = typeName.replace('(', '').replace(')', '').split('|');\n        const typeLinks = typeNames.map(v => this._buildDocLinkHTML(v));\n        return `...(${ typeLinks.join('|') })`;\n      } else {\n        return `...${ this._buildDocLinkHTML(typeName) }`;\n      }\n    } else if (typeName.indexOf('?') === 0) {\n      typeName = typeName.replace('?', '');\n      return `?${ this._buildDocLinkHTML(typeName) }`;\n    } else {\n      return this._buildDocLinkHTML(typeName);\n    }\n  }\n\n  /**\n   * build html link to identifier.\n   * @param {string} longname - link to this.\n   * @param {string} [text] - link text. default is name property of doc object.\n   * @param {boolean} [inner=false] - if true, use inner link.\n   * @param {string} [kind] - specify target kind property.\n   * @returns {string} html of link.\n   * @private\n   */\n  _buildDocLinkHTML(longname, text = null, inner = false, kind = null) {\n    if (!longname) return '';\n\n    if (typeof longname !== 'string') throw new Error(JSON.stringify(longname));\n\n    const doc = this._findByName(longname, kind)[0];\n\n    if (!doc) {\n      // if longname is HTML tag, not escape.\n      if (longname.indexOf('<') === 0) {\n        return `<span>${ longname }</span>`;\n      } else {\n        return `<span>${ (0, _escapeHtml2.default)(text || longname) }</span>`;\n      }\n    }\n\n    if (doc.kind === 'external') {\n      text = doc.name;\n      return `<span><a href=\"${ doc.externalLink }\">${ text }</a></span>`;\n    } else {\n      text = (0, _escapeHtml2.default)(text || doc.name);\n      const url = this._getURL(doc, inner);\n      if (url) {\n        return `<span><a href=\"${ url }\">${ text }</a></span>`;\n      } else {\n        return `<span>${ text }</span>`;\n      }\n    }\n  }\n\n  /**\n   * build html links to identifiers\n   * @param {string[]} longnames - link to these.\n   * @param {string} [text] - link text. default is name property of doc object.\n   * @param {boolean} [inner=false] - if true, use inner link.\n   * @param {string} [separator='\\n'] - used link separator.\n   * @returns {string} html links.\n   * @private\n   */\n  _buildDocsLinkHTML(longnames, text = null, inner = false, separator = '\\n') {\n    if (!longnames) return '';\n    if (!longnames.length) return '';\n\n    const links = [];\n    for (const longname of longnames) {\n      if (!longname) continue;\n      const link = this._buildDocLinkHTML(longname, text, inner);\n      links.push(`<li>${ link }</li>`);\n    }\n\n    if (!links.length) return '';\n\n    return `<ul>${ links.join(separator) }</ul>`;\n  }\n\n  /**\n   * build identifier signature html.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} signature html.\n   * @private\n   */\n  _buildSignatureHTML(doc) {\n    // call signature\n    const callSignatures = [];\n    if (doc.params) {\n      for (const param of doc.params) {\n        const paramName = param.name;\n        if (paramName.indexOf('.') !== -1) continue; // for object property\n        if (paramName.indexOf('[') !== -1) continue; // for array property\n\n        const types = [];\n        for (const typeName of param.types) {\n          types.push(this._buildTypeDocLinkHTML(typeName));\n        }\n\n        callSignatures.push(`${ paramName }: ${ types.join(' | ') }`);\n      }\n    }\n\n    // return signature\n    const returnSignatures = [];\n    if (doc.return) {\n      for (const typeName of doc.return.types) {\n        returnSignatures.push(this._buildTypeDocLinkHTML(typeName));\n      }\n    }\n\n    // type signature\n    let typeSignatures = [];\n    if (doc.type) {\n      for (const typeName of doc.type.types) {\n        typeSignatures.push(this._buildTypeDocLinkHTML(typeName));\n      }\n    }\n\n    // callback is not need type. because type is always function.\n    if (doc.kind === 'function') {\n      typeSignatures = [];\n    }\n\n    let html = '';\n    if (callSignatures.length) {\n      html = `(${ callSignatures.join(', ') })`;\n    } else if (['function', 'method', 'constructor'].includes(doc.kind)) {\n      html = '()';\n    }\n    if (returnSignatures.length) html = `${ html }: ${ returnSignatures.join(' | ') }`;\n    if (typeSignatures.length) html = `${ html }: ${ typeSignatures.join(' | ') }`;\n\n    return html;\n  }\n\n  /**\n   * build properties output.\n   * @param {ParsedParam[]} [properties=[]] - properties in doc object.\n   * @param {string} title - output title.\n   * @return {IceCap} built properties output.\n   * @private\n   */\n  _buildProperties(properties = [], title = 'Properties:') {\n    const ice = new _iceCap2.default(this._readTemplate('properties.html'));\n\n    ice.text('title', title);\n\n    ice.loop('property', properties, (i, prop, ice) => {\n      ice.autoDrop = false;\n      ice.attr('property', 'data-depth', prop.name.split('.').length - 1);\n      ice.text('name', prop.name);\n      ice.attr('name', 'data-depth', prop.name.split('.').length - 1);\n      ice.load('description', prop.description);\n\n      const typeNames = [];\n      for (const typeName of prop.types) {\n        typeNames.push(this._buildTypeDocLinkHTML(typeName));\n      }\n      ice.load('type', typeNames.join(' | '));\n\n      // appendix\n      const appendix = [];\n      if (prop.optional) {\n        appendix.push('<li>optional</li>');\n      }\n      if ('defaultValue' in prop) {\n        appendix.push(`<li>default: ${ prop.defaultValue }</li>`);\n      }\n      if (typeof prop.nullable === 'boolean') {\n        appendix.push(`<li>nullable: ${ prop.nullable }</li>`);\n      }\n      if (appendix.length) {\n        ice.load('appendix', `<ul>${ appendix.join('\\n') }</ul>`);\n      } else {\n        ice.text('appendix', '');\n      }\n    });\n\n    if (!properties || properties.length === 0) {\n      ice.drop('properties');\n    }\n\n    return ice;\n  }\n\n  /**\n   * build deprecated html.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} if doc is not deprecated, returns empty.\n   * @private\n   */\n  _buildDeprecatedHTML(doc) {\n    if (doc.deprecated) {\n      const deprecated = [`this ${ doc.kind } was deprecated.`];\n      if (typeof doc.deprecated === 'string') deprecated.push(doc.deprecated);\n      return deprecated.join(' ');\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * build experimental html.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} if doc is not experimental, returns empty.\n   * @private\n   */\n  _buildExperimentalHTML(doc) {\n    if (doc.experimental) {\n      const experimental = [`this ${ doc.kind } is experimental.`];\n      if (typeof doc.experimental === 'string') experimental.push(doc.experimental);\n      return experimental.join(' ');\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * build method of ancestor class link html.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} html link. if doc does not override ancestor method, returns empty.\n   * @private\n   */\n  _buildOverrideMethod(doc) {\n    const parentDoc = this._findByName(doc.memberof)[0];\n    if (!parentDoc) return '';\n    if (!parentDoc._custom_extends_chains) return '';\n\n    const chains = [...parentDoc._custom_extends_chains].reverse();\n    for (const longname of chains) {\n      const superClassDoc = this._findByName(longname)[0];\n      if (!superClassDoc) continue;\n\n      const superMethodDoc = this._find({ name: doc.name, memberof: superClassDoc.longname })[0];\n      if (!superMethodDoc) continue;\n\n      return this._buildDocLinkHTML(superMethodDoc.longname, `${ superClassDoc.name }#${ superMethodDoc.name }`, true);\n    }\n\n    return '';\n  }\n\n  /**\n   * build method of ancestor class description.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} description. if doc does not override ancestor method, returns empty.\n   * @private\n   */\n  _buildOverrideMethodDescription(doc) {\n    const parentDoc = this._findByName(doc.memberof)[0];\n    if (!parentDoc) return '';\n    if (!parentDoc._custom_extends_chains) return '';\n\n    const chains = [...parentDoc._custom_extends_chains].reverse();\n    for (const longname of chains) {\n      const superClassDoc = this._findByName(longname)[0];\n      if (!superClassDoc) continue;\n\n      const superMethodDoc = this._find({ name: doc.name, memberof: superClassDoc.longname })[0];\n      if (!superMethodDoc) continue;\n\n      if (superMethodDoc.description) return superMethodDoc.description;\n    }\n\n    return '';\n  }\n\n  _buildDecoratorHTML(doc) {\n    if (!doc.decorators) return '';\n\n    const links = [];\n    for (const decorator of doc.decorators) {\n      const link = this._buildDocLinkHTML(decorator.name, decorator.name, false, 'function');\n      if (decorator.arguments) {\n        links.push(`<li>${ link }${ decorator.arguments }</li>`);\n      } else {\n        links.push(`<li>${ link }</li>`);\n      }\n    }\n\n    if (!links.length) return '';\n\n    return `<ul>${ links.join('\\n') }</ul>`;\n  }\n\n  // _buildAuthorHTML(doc, separator = '\\n') {\n  //  if (!doc.author) return '';\n  //\n  //  var html = [];\n  //  for (var author of doc.author) {\n  //    var matched = author.match(/(.*?) *<(.*?)>/);\n  //    if (matched) {\n  //      var name = matched[1];\n  //      var link = matched[2];\n  //      if (link.indexOf('http') === 0) {\n  //        html.push(`<li><a href=\"${link}\">${name}</a></li>`)\n  //      } else {\n  //        html.push(`<li><a href=\"mailto:${link}\">${name}</a></li>`)\n  //      }\n  //    } else {\n  //      html.push(`<li>${author}</li>`)\n  //    }\n  //  }\n  //\n  //  return `<ul>${html.join(separator)}</ul>`;\n  // }\n}\nexports.default = DocBuilder; /* eslint-disable max-lines */","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/util.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shorten = shorten;\nexports.markdown = markdown;\nexports.dateForUTC = dateForUTC;\nexports.parseExample = parseExample;\n\nvar _marked = require('marked');\n\nvar _marked2 = _interopRequireDefault(_marked);\n\nvar _escapeHtml = require('escape-html');\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * shorten description.\n * e.g. ``this is JavaScript. this is Java.`` => ``this is JavaScript.``.\n *\n * @param {DocObject} doc - target doc object.\n * @param {boolean} [asMarkdown=false] - is true, test as markdown and convert to html.\n * @returns {string} shorten description.\n * @todo shorten before process markdown.\n */\nfunction shorten(doc, asMarkdown = false) {\n  if (!doc) return '';\n\n  if (doc.summary) return doc.summary;\n\n  const desc = doc.descriptionRaw;\n  if (!desc) return '';\n\n  let len = desc.length;\n  let inSQuote = false;\n  let inWQuote = false;\n  let inCode = false;\n  for (let i = 0; i < desc.length; i++) {\n    const char1 = desc.charAt(i);\n    const char2 = desc.charAt(i + 1);\n    const char4 = desc.substr(i, 6);\n    const char5 = desc.substr(i, 7);\n    if (char1 === '\\'') inSQuote = !inSQuote;else if (char1 === '\"') inWQuote = !inWQuote;else if (char4 === '<code>') inCode = true;else if (char5 === '</code>') inCode = false;\n\n    if (inSQuote || inCode || inWQuote) continue;\n\n    if (char1 === '.') {\n      if (char2 === ' ' || char2 === '\\n' || char2 === '<') {\n        len = i + 1;\n        break;\n      }\n    } else if (char1 === '\\n' && char2 === '\\n') {\n      len = i + 1;\n      break;\n    }\n  }\n\n  let result = desc.substr(0, len);\n  if (asMarkdown) {\n    result = markdown(result);\n  }\n\n  return result;\n}\n\n/**\n * convert markdown text to html.\n * @param {string} text - markdown text.\n * @param {boolean} [breaks=false] if true, break line. FYI gfm is not breaks.\n * @return {string} html.\n */\nfunction markdown(text, breaks = false) {\n  const availableTags = ['span', 'a', 'p', 'div', 'img', 'h1', 'h2', 'h3', 'h4', 'h5', 'br', 'hr', 'li', 'ul', 'ol', 'code', 'pre'];\n  const availableAttributes = ['src', 'href', 'title', 'class', 'id', 'name', 'width', 'height', 'target'];\n\n  const compiled = (0, _marked2.default)(text, {\n    gfm: true,\n    tables: true,\n    breaks: breaks,\n    sanitize: true,\n    sanitizer: tag => {\n      if (tag.match(/<!--.*-->/)) {\n        return tag;\n      }\n      const tagName = tag.match(/^<\\/?(\\w+)/)[1];\n      if (!availableTags.includes(tagName)) {\n        return (0, _escapeHtml2.default)(tag);\n      }\n\n      const sanitizedTag = tag.replace(/([\\w\\-]+)=([\"'].*?[\"'])/g, (_, attr, val) => {\n        if (!availableAttributes.includes(attr)) return '';\n        /* eslint-disable no-script-url */\n        if (val.indexOf('javascript:') !== -1) return '';\n        return `${ attr }=${ val }`;\n      });\n\n      return sanitizedTag;\n    },\n    highlight: function (code) {\n      // return `<pre class=\"source-code\"><code class=\"prettyprint\">${escape(code)}</code></pre>`;\n      return `<code class=\"source-code prettyprint\">${ (0, _escapeHtml2.default)(code) }</code>`;\n    }\n  });\n\n  return compiled;\n}\n\n/**\n * get UTC date string.\n * @param {Date} date - target date object.\n * @returns {string} UTC date string(yyyy-mm-dd hh:mm:ss)\n */\nfunction dateForUTC(date) {\n  function pad(num, len) {\n    const count = Math.max(0, len - `${ num }`.length);\n    return '0'.repeat(count) + num;\n  }\n\n  const year = date.getUTCFullYear();\n  const month = pad(date.getUTCMonth() + 1, 2);\n  const day = pad(date.getUTCDay() + 1, 2);\n  const hours = pad(date.getUTCHours(), 2);\n  const minutes = pad(date.getUTCMinutes(), 2);\n  const seconds = pad(date.getUTCSeconds(), 2);\n\n  return `${ year }-${ month }-${ day } ${ hours }:${ minutes }:${ seconds } (UTC)`;\n}\n\n/**\n * parse ``@example`` value.\n * ``@example`` value can have ``<caption>`` tag.\n *\n * @param {string} example - target example value.\n * @returns {{body: string, caption: string}} parsed example value.\n */\nfunction parseExample(example) {\n  let body = example;\n  let caption = '';\n\n  /* eslint-disable no-control-regex */\n  const regexp = new RegExp('^<caption>(.*?)</caption>\\n');\n  const matched = example.match(regexp);\n  if (matched) {\n    body = example.replace(regexp, '');\n    caption = matched[1].trim();\n  }\n\n  return { body, caption };\n}","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/DocResolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _util = require('./util.js');\n\n/**\n * Resolve various properties in doc object.\n */\nclass DocResolver {\n  /**\n   * create instance.\n   * @param {DocBuilder} builder - target doc builder.\n   */\n  constructor(builder) {\n    this._builder = builder;\n    this._data = builder._data;\n  }\n\n  /**\n   * resolve various properties.\n   */\n  resolve() {\n    if (this._data.__RESOLVED_ALL__) return;\n\n    console.log('resolve: extends chain');\n    this._resolveExtendsChain();\n\n    console.log('resolve: necessary');\n    this._resolveNecessary();\n\n    console.log('resolve: access');\n    this._resolveAccess();\n\n    console.log('resolve: unexported identifier');\n    this._resolveUnexportIdentifier();\n\n    console.log('resolve: undocument identifier');\n    this._resolveUndocumentIdentifier();\n\n    console.log('resolve: duplication');\n    this._resolveDuplication();\n\n    console.log('resolve: ignore');\n    this._resolveIgnore();\n\n    console.log('resolve: link');\n    this._resolveLink();\n\n    console.log('resolve: markdown in description');\n    this._resolveMarkdown();\n\n    console.log('resolve: test relation');\n    this._resolveTestRelation();\n\n    this._data.__RESOLVED_ALL__ = true;\n  }\n\n  /**\n   * resolve ignore property.\n   * remove docs that has ignore property.\n   * @private\n   */\n  _resolveIgnore() {\n    if (this._data.__RESOLVED_IGNORE__) return;\n\n    const docs = this._builder._find({ ignore: true });\n    for (const doc of docs) {\n      const longname = doc.longname.replace(/[$]/g, '\\\\$');\n      const regex = new RegExp(`^${ longname }[.~#]`);\n      this._data({ longname: { regex: regex } }).remove();\n    }\n    this._data({ ignore: true }).remove();\n\n    this._data.__RESOLVED_IGNORE__ = true;\n  }\n\n  /**\n   * resolve access property.\n   * if doc does not have access property, the doc is public.\n   * but name is started with '-', the doc is private.\n   * @private\n   */\n  _resolveAccess() {\n    if (this._data.__RESOLVED_ACCESS__) return;\n\n    const config = this._builder._config;\n    const access = config.access || ['public', 'protected', 'private'];\n    const autoPrivate = config.autoPrivate;\n\n    /* eslint-disable no-invalid-this */\n    this._data().update(function () {\n      if (!this.access) {\n        if (autoPrivate && this.name.charAt(0) === '_') {\n          /** @ignore */\n          this.access = 'private';\n        } else {\n          this.access = 'public';\n        }\n      }\n\n      if (!access.includes(this.access)) /** @ignore */this.ignore = true;\n\n      return this;\n    });\n\n    this._data.__RESOLVED_ACCESS__ = true;\n  }\n\n  /**\n   * resolve unexport identifier doc.\n   * doc is added ignore property that is not exported.\n   * @private\n   */\n  _resolveUnexportIdentifier() {\n    if (this._data.__RESOLVED_UNEXPORT_IDENTIFIER__) return;\n\n    const config = this._builder._config;\n    if (!config.unexportIdentifier) {\n      this._data({ export: false }).update({ ignore: true });\n    }\n\n    this._data.__RESOLVED_UNEXPORT_IDENTIFIER__ = true;\n  }\n\n  /**\n   * resolve undocument identifier doc.\n   * doc is added ignore property that does not have document tag.\n   * @private\n   */\n  _resolveUndocumentIdentifier() {\n    if (this._data.__RESOLVED_UNDOCUMENT_IDENTIFIER__) return;\n\n    if (!this._builder._config.undocumentIdentifier) {\n      this._builder._data({ undocument: true }).update({ ignore: true });\n    }\n\n    this._data.__RESOLVED_UNDOCUMENT_IDENTIFIER__ = true;\n  }\n\n  /**\n   * resolve description as markdown.\n   * @private\n   */\n  _resolveMarkdown() {\n    if (this._data.__RESOLVED_MARKDOWN__) return;\n\n    function convert(obj) {\n      for (const key of Object.keys(obj)) {\n        const value = obj[key];\n        if (key === 'description' && typeof value === 'string') {\n          obj[`${ key }Raw`] = obj[key];\n          obj[key] = (0, _util.markdown)(value, false);\n        } else if (typeof value === 'object' && value) {\n          convert(value);\n        }\n      }\n    }\n\n    const docs = this._builder._find();\n    for (const doc of docs) {\n      convert(doc);\n    }\n\n    this._data.__RESOLVED_MARKDOWN__ = true;\n  }\n\n  /**\n   * resolve @link as html link.\n   * @private\n   * @todo resolve all ``description`` property.\n   */\n  _resolveLink() {\n    if (this._data.__RESOLVED_LINK__) return;\n\n    const link = str => {\n      if (!str) return str;\n\n      return str.replace(/\\{@link ([\\w#_\\-.:~\\/$]+)}/g, (str, longname) => {\n        return this._builder._buildDocLinkHTML(longname, longname);\n      });\n    };\n\n    this._data().each(v => {\n      v.description = link(v.description);\n\n      if (v.params) {\n        for (const param of v.params) {\n          param.description = link(param.description);\n        }\n      }\n\n      if (v.properties) {\n        for (const property of v.properties) {\n          property.description = link(property.description);\n        }\n      }\n\n      if (v.return) {\n        v.return.description = link(v.return.description);\n      }\n\n      if (v.throws) {\n        for (const _throw of v.throws) {\n          _throw.description = link(_throw.description);\n        }\n      }\n\n      if (v.see) {\n        for (let i = 0; i < v.see.length; i++) {\n          if (v.see[i].indexOf('{@link') === 0) {\n            v.see[i] = link(v.see[i]);\n          } else if (v.see[i].indexOf('<a href') === 0) {\n            // ignore\n          } else {\n            v.see[i] = `<a href=\"${ v.see[i] }\">${ v.see[i] }</a>`;\n          }\n        }\n      }\n    });\n\n    this._data.__RESOLVED_LINK__ = true;\n  }\n\n  /**\n   * resolve class extends chain.\n   * add following special property.\n   * - ``_custom_extends_chain``: ancestor class chain.\n   * - ``_custom_direct_subclasses``: class list that direct extends target doc.\n   * - ``_custom_indirect_subclasses``: class list that indirect extends target doc.\n   * - ``_custom_indirect_implements``: class list that target doc indirect implements.\n   * - ``_custom_direct_implemented``: class list that direct implements target doc.\n   * - ``_custom_indirect_implemented``: class list that indirect implements target doc.\n   *\n   * @private\n   */\n  _resolveExtendsChain() {\n    if (this._data.__RESOLVED_EXTENDS_CHAIN__) return;\n\n    const extendsChain = doc => {\n      if (!doc.extends) return;\n\n      const selfDoc = doc;\n\n      // traverse super class.\n      const chains = [];\n\n      /* eslint-disable */\n      while (1) {\n        if (!doc.extends) break;\n\n        let superClassDoc = this._builder._findByName(doc.extends[0])[0];\n\n        if (superClassDoc) {\n          // this is circular extends\n          if (superClassDoc.longname === selfDoc.longname) {\n            break;\n          }\n\n          chains.push(superClassDoc.longname);\n          doc = superClassDoc;\n        } else {\n          chains.push(doc.extends[0]);\n          break;\n        }\n      }\n\n      if (chains.length) {\n        // direct subclass\n        let superClassDoc = this._builder._findByName(chains[0])[0];\n        if (superClassDoc) {\n          if (!superClassDoc._custom_direct_subclasses) superClassDoc._custom_direct_subclasses = [];\n          superClassDoc._custom_direct_subclasses.push(selfDoc.longname);\n        }\n\n        // indirect subclass\n        for (let superClassLongname of chains.slice(1)) {\n          superClassDoc = this._builder._findByName(superClassLongname)[0];\n          if (superClassDoc) {\n            if (!superClassDoc._custom_indirect_subclasses) superClassDoc._custom_indirect_subclasses = [];\n            superClassDoc._custom_indirect_subclasses.push(selfDoc.longname);\n          }\n        }\n\n        // indirect implements and mixes\n        for (let superClassLongname of chains) {\n          superClassDoc = this._builder._findByName(superClassLongname)[0];\n          if (!superClassDoc) continue;\n\n          // indirect implements\n          if (superClassDoc.implements) {\n            if (!selfDoc._custom_indirect_implements) selfDoc._custom_indirect_implements = [];\n            selfDoc._custom_indirect_implements.push(...superClassDoc.implements);\n          }\n\n          // indirect mixes\n          //if (superClassDoc.mixes) {\n          //  if (!selfDoc._custom_indirect_mixes) selfDoc._custom_indirect_mixes = [];\n          //  selfDoc._custom_indirect_mixes.push(...superClassDoc.mixes);\n          //}\n        }\n\n        // extends chains\n        selfDoc._custom_extends_chains = chains.reverse();\n      }\n    };\n\n    let implemented = doc => {\n      let selfDoc = doc;\n\n      // direct implemented (like direct subclass)\n      for (let superClassLongname of selfDoc.implements || []) {\n        let superClassDoc = this._builder._findByName(superClassLongname)[0];\n        if (!superClassDoc) continue;\n        if (!superClassDoc._custom_direct_implemented) superClassDoc._custom_direct_implemented = [];\n        superClassDoc._custom_direct_implemented.push(selfDoc.longname);\n      }\n\n      // indirect implemented (like indirect subclass)\n      for (let superClassLongname of selfDoc._custom_indirect_implements || []) {\n        let superClassDoc = this._builder._findByName(superClassLongname)[0];\n        if (!superClassDoc) continue;\n        if (!superClassDoc._custom_indirect_implemented) superClassDoc._custom_indirect_implemented = [];\n        superClassDoc._custom_indirect_implemented.push(selfDoc.longname);\n      }\n    };\n\n    //var mixed = (doc) =>{\n    //  var selfDoc = doc;\n    //\n    //  // direct mixed (like direct subclass)\n    //  for (var superClassLongname of selfDoc.mixes || []) {\n    //    var superClassDoc = this._builder._find({longname: superClassLongname})[0];\n    //    if (!superClassDoc) continue;\n    //    if(!superClassDoc._custom_direct_mixed) superClassDoc._custom_direct_mixed = [];\n    //    superClassDoc._custom_direct_mixed.push(selfDoc.longname);\n    //  }\n    //\n    //  // indirect mixed (like indirect subclass)\n    //  for (var superClassLongname of selfDoc._custom_indirect_mixes || []) {\n    //    var superClassDoc = this._builder._find({longname: superClassLongname})[0];\n    //    if (!superClassDoc) continue;\n    //    if(!superClassDoc._custom_indirect_mixed) superClassDoc._custom_indirect_mixed = [];\n    //    superClassDoc._custom_indirect_mixed.push(selfDoc.longname);\n    //  }\n    //};\n\n    let docs = this._builder._find({ kind: 'class' });\n    for (let doc of docs) {\n      extendsChain(doc);\n      implemented(doc);\n      //mixed(doc);\n    }\n\n    this._data.__RESOLVED_EXTENDS_CHAIN__ = true;\n  }\n\n  /**\n   * resolve necessary identifier.\n   *\n   * ```javascript\n   * class Foo {}\n   *\n   * export default Bar extends Foo {}\n   * ```\n   *\n   * ``Foo`` is not exported, but ``Bar`` extends ``Foo``.\n   * ``Foo`` is necessary.\n   * So, ``Foo`` must be exported by force.\n   *\n   * @private\n   */\n  _resolveNecessary() {\n    let builder = this._builder;\n    this._data({ export: false }).update(function () {\n      let doc = this;\n      let childNames = [];\n      if (doc._custom_direct_subclasses) childNames.push(...doc._custom_direct_subclasses);\n      if (doc._custom_indirect_subclasses) childNames.push(...doc._custom_indirect_subclasses);\n      if (doc._custom_direct_implemented) childNames.push(...doc._custom_direct_implemented);\n      if (doc._custom_indirect_implemented) childNames.push(...doc._custom_indirect_implemented);\n\n      for (let childName of childNames) {\n        let childDoc = builder._find({ longname: childName })[0];\n        if (!childDoc) continue;\n        if (!childDoc.ignore && childDoc.export) {\n          doc.export = true;\n          return doc;\n        }\n      }\n    });\n  }\n\n  /**\n   * resolve test and identifier relation. add special property.\n   * - ``_custom_tests``: longnames of test doc.\n   * - ``_custom_test_targets``: longnames of identifier.\n   *\n   * @private\n   */\n  _resolveTestRelation() {\n    if (this._data.__RESOLVED_TEST_RELATION__) return;\n\n    let testDocs = this._builder._find({ kind: ['testDescribe', 'testIt'] });\n    for (let testDoc of testDocs) {\n      let testTargets = testDoc.testTargets;\n      if (!testTargets) continue;\n\n      for (let testTarget of testTargets) {\n        let doc = this._builder._findByName(testTarget)[0];\n        if (doc) {\n          if (!doc._custom_tests) doc._custom_tests = [];\n          doc._custom_tests.push(testDoc.longname);\n\n          if (!testDoc._custom_test_targets) testDoc._custom_test_targets = [];\n          testDoc._custom_test_targets.push([doc.longname, testTarget]);\n        } else {\n          if (!testDoc._custom_test_targets) testDoc._custom_test_targets = [];\n          testDoc._custom_test_targets.push([testTarget, testTarget]);\n        }\n      }\n    }\n\n    // test full description\n    for (let testDoc of testDocs) {\n      let desc = [];\n      let parents = (testDoc.memberof.split('~')[1] || '').split('.');\n      for (let parent of parents) {\n        let doc = this._builder._find({ kind: ['testDescribe', 'testIt'], name: parent })[0];\n        if (!doc) continue;\n        desc.push(doc.descriptionRaw);\n      }\n      desc.push(testDoc.descriptionRaw);\n      testDoc.testFullDescription = desc.join(' ');\n    }\n\n    this._data.__RESOLVED_TEST_RELATION__ = true;\n  }\n\n  /**\n   * resolve duplication identifier.\n   * member doc is possible duplication.\n   * other doc is not duplication.\n   * @private\n   */\n  _resolveDuplication() {\n    if (this._data.__RESOLVED_DUPLICATION__) return;\n\n    let docs = this._builder._find({ kind: 'member' });\n    let ignoreId = [];\n    for (let doc of docs) {\n      // member duplicate with getter/setter/method.\n      // when it, remove member.\n      // getter/setter/method are high priority.\n      const nonMemberDup = this._builder._find({ longname: doc.longname, kind: { '!is': 'member' } });\n      if (nonMemberDup.length) {\n        ignoreId.push(doc.___id);\n        continue;\n      }\n\n      let dup = this._builder._find({ longname: doc.longname, kind: 'member' });\n      if (dup.length > 1) {\n        let ids = dup.map(v => v.___id);\n        ids.sort((a, b) => {\n          return a < b ? -1 : 1;\n        });\n        ids.shift();\n        ignoreId.push(...ids);\n      }\n    }\n\n    this._data({ ___id: ignoreId }).update(function () {\n      this.ignore = true;\n      return this;\n    });\n\n    this._data.__RESOLVED_DUPLICATION__ = true;\n  }\n}\nexports.default = DocResolver;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Util/NPMUtil.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fsExtra = require('fs-extra');\n\nvar _fsExtra2 = _interopRequireDefault(_fsExtra);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Node Package Manager(npm) util class.\n */\nclass NPMUtil {\n\n  /**\n   * find ESDoc package.json object.\n   * @returns {Object} package.json object.\n   */\n  static findPackage() {\n    let packageObj = null;\n    try {\n      const packageFilePath = _path2.default.resolve(__dirname, '../../package.json');\n      const json = _fsExtra2.default.readFileSync(packageFilePath, { encode: 'utf8' });\n      packageObj = JSON.parse(json);\n    } catch (e) {\n      const packageFilePath = _path2.default.resolve(__dirname, '../../../package.json');\n      const json = _fsExtra2.default.readFileSync(packageFilePath, { encode: 'utf8' });\n      packageObj = JSON.parse(json);\n    }\n\n    return packageObj;\n  }\n}\nexports.default = NPMUtil;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/IdentifiersDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Identifier output builder class.\n */\nclass IdentifiersDocBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output.\n   * @param {function(html: string, filePath: string)} callback - is called with output.\n   */\n  exec(callback) {\n    const ice = this._buildLayoutDoc();\n    const title = this._getTitle('Index');\n    ice.load('content', this._buildIdentifierDoc());\n    ice.text('title', title, _iceCap2.default.MODE_WRITE);\n    callback(ice.html, 'identifiers.html');\n  }\n\n  /**\n   * build identifier output.\n   * @return {IceCap} built output.\n   * @private\n   */\n  _buildIdentifierDoc() {\n    const indexInfo = this._getInfo();\n\n    const ice = new _iceCap2.default(this._readTemplate('identifiers.html'));\n\n    ice.text('title', indexInfo.title);\n    ice.text('version', indexInfo.version, 'append');\n    ice.text('url', indexInfo.url);\n    ice.attr('url', 'href', indexInfo.url);\n    ice.text('description', indexInfo.desc);\n\n    ice.load('classSummary', this._buildSummaryHTML(null, 'class', 'Class Summary'), 'append');\n    ice.load('interfaceSummary', this._buildSummaryHTML(null, 'interface', 'Interface Summary'), 'append');\n    ice.load('functionSummary', this._buildSummaryHTML(null, 'function', 'Function Summary'), 'append');\n    ice.load('variableSummary', this._buildSummaryHTML(null, 'variable', 'Variable Summary'), 'append');\n    ice.load('typedefSummary', this._buildSummaryHTML(null, 'typedef', 'Typedef Summary'), 'append');\n    ice.load('externalSummary', this._buildSummaryHTML(null, 'external', 'External Summary'), 'append');\n\n    return ice;\n  }\n}\nexports.default = IdentifiersDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/IndexDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nvar _util = require('./util.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Index output builder class.\n */\nclass IndexDocBuilder extends _DocBuilder2.default {\n  /**\n   * create instance.\n   * @param {Taffy} data - doc object database.\n   * @param {ESDocConfig} config - use config to build output.\n   * @param {CoverageObject} coverage - use coverage to build output.\n   */\n  constructor(data, config, coverage) {\n    super(data, config);\n    this._coverage = coverage;\n  }\n\n  /**\n   * execute building output.\n   * @param {function(html: string, filePath: string)} callback - is called with output.\n   */\n  exec(callback) {\n    const ice = this._buildLayoutDoc();\n    const title = this._getTitle();\n    ice.load('content', this._buildIndexDoc());\n    ice.text('title', title, _iceCap2.default.MODE_WRITE);\n    callback(ice.html, 'index.html');\n  }\n\n  /**\n   * build index output.\n   * @returns {string} html of index output.\n   * @private\n   */\n  _buildIndexDoc() {\n    if (!this._config.index) return 'Please create README.md';\n\n    let indexContent;\n    try {\n      indexContent = _fs2.default.readFileSync(this._config.index, { encode: 'utf8' }).toString();\n    } catch (e) {\n      return 'Please create README.md';\n    }\n\n    const html = this._readTemplate('index.html');\n    const ice = new _iceCap2.default(html);\n    const ext = _path2.default.extname(this._config.index);\n    if (['.md', '.markdown'].includes(ext)) {\n      ice.load('index', (0, _util.markdown)(indexContent));\n    } else {\n      ice.load('index', indexContent);\n    }\n\n    return ice.html;\n  }\n}\nexports.default = IndexDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/ClassDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nvar _util = require('./util.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Class Output Builder class.\n */\nclass ClassDocBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output.\n   * @param {function(html: string, filePath: string)} callback - is called each class.\n   */\n  exec(callback) {\n    const ice = this._buildLayoutDoc();\n    ice.autoDrop = false;\n    const docs = this._find({ kind: ['class'] });\n    for (const doc of docs) {\n      const fileName = this._getOutputFileName(doc);\n      const baseUrl = this._getBaseUrl(fileName);\n      const title = this._getTitle(doc);\n      ice.load('content', this._buildClassDoc(doc), _iceCap2.default.MODE_WRITE);\n      ice.attr('baseUrl', 'href', baseUrl, _iceCap2.default.MODE_WRITE);\n      ice.text('title', title, _iceCap2.default.MODE_WRITE);\n      callback(ice.html, fileName);\n    }\n  }\n\n  /**\n   * build class output.\n   * @param {DocObject} doc - class doc object.\n   * @returns {IceCap} built output.\n   * @private\n   */\n  _buildClassDoc(doc) {\n    const expressionExtends = this._buildExpressionExtendsHTML(doc);\n    const mixinClasses = this._buildMixinClassesHTML(doc);\n    const extendsChain = this._buildExtendsChainHTML(doc);\n    const directSubclass = this._buildDirectSubclassHTML(doc);\n    const indirectSubclass = this._buildIndirectSubclassHTML(doc);\n    const instanceDocs = this._find({ kind: 'variable' }).filter(v => {\n      return v.type && v.type.types.includes(doc.longname);\n    });\n\n    const ice = new _iceCap2.default(this._readTemplate('class.html'));\n\n    // header\n    if (doc.export && doc.importPath && doc.importStyle) {\n      const link = this._buildFileDocLinkHTML(doc, doc.importPath);\n      ice.into('importPath', `import ${ doc.importStyle } from '${ link }'`, (code, ice) => {\n        ice.load('importPathCode', code);\n      });\n    }\n    ice.text('access', doc.access);\n    ice.text('kind', doc.interface ? 'interface' : 'class');\n    ice.load('source', this._buildFileDocLinkHTML(doc, 'source'), 'append');\n    ice.text('since', doc.since, 'append');\n    ice.text('version', doc.version, 'append');\n    ice.load('variation', this._buildVariationHTML(doc), 'append');\n\n    ice.into('expressionExtends', expressionExtends, (expressionExtends, ice) => ice.load('expressionExtendsCode', expressionExtends));\n    ice.load('mixinExtends', mixinClasses, 'append');\n    ice.load('extendsChain', extendsChain, 'append');\n    ice.load('directSubclass', directSubclass, 'append');\n    ice.load('indirectSubclass', indirectSubclass, 'append');\n    ice.load('implements', this._buildDocsLinkHTML(doc.implements, null, false, ', '), 'append');\n    ice.load('indirectImplements', this._buildDocsLinkHTML(doc._custom_indirect_implements, null, false, ', '), 'append');\n    ice.load('directImplemented', this._buildDocsLinkHTML(doc._custom_direct_implemented, null, false, ', '), 'append');\n    ice.load('indirectImplemented', this._buildDocsLinkHTML(doc._custom_indirect_implemented, null, false, ', '), 'append');\n\n    // self\n    ice.text('name', doc.name);\n    ice.load('description', doc.description);\n    ice.load('deprecated', this._buildDeprecatedHTML(doc));\n    ice.load('experimental', this._buildExperimentalHTML(doc));\n    ice.load('see', this._buildDocsLinkHTML(doc.see), 'append');\n    ice.load('todo', this._buildDocsLinkHTML(doc.todo), 'append');\n    ice.load('decorator', this._buildDecoratorHTML(doc), 'append');\n\n    ice.into('instanceDocs', instanceDocs, (instanceDocs, ice) => {\n      ice.loop('instanceDoc', instanceDocs, (i, instanceDoc, ice) => {\n        ice.load('instanceDoc', this._buildDocLinkHTML(instanceDoc.longname));\n      });\n    });\n\n    ice.into('exampleDocs', doc.examples, (examples, ice) => {\n      ice.loop('exampleDoc', examples, (i, example, ice) => {\n        const parsed = (0, _util.parseExample)(example);\n        ice.text('exampleCode', parsed.body);\n        ice.text('exampleCaption', parsed.caption);\n      });\n    });\n\n    ice.into('tests', doc._custom_tests, (tests, ice) => {\n      ice.loop('test', tests, (i, test, ice) => {\n        const testDoc = this._find({ longname: test })[0];\n        ice.load('test', this._buildFileDocLinkHTML(testDoc, testDoc.testFullDescription));\n      });\n    });\n\n    // summary\n    ice.load('staticMemberSummary', this._buildSummaryHTML(doc, 'member', 'Members', true));\n    ice.load('staticMethodSummary', this._buildSummaryHTML(doc, 'method', 'Methods', true));\n    ice.load('constructorSummary', this._buildSummaryHTML(doc, 'constructor', 'Constructor', false));\n    ice.load('memberSummary', this._buildSummaryHTML(doc, 'member', 'Members', false));\n    ice.load('methodSummary', this._buildSummaryHTML(doc, 'method', 'Methods', false));\n\n    ice.load('inheritedSummary', this._buildInheritedSummaryHTML(doc), 'append');\n\n    // detail\n    ice.load('staticMemberDetails', this._buildDetailHTML(doc, 'member', 'Members', true));\n    ice.load('staticMethodDetails', this._buildDetailHTML(doc, 'method', 'Methods', true));\n    ice.load('constructorDetails', this._buildDetailHTML(doc, 'constructor', 'Constructors', false));\n    ice.load('memberDetails', this._buildDetailHTML(doc, 'member', 'Members', false));\n    ice.load('methodDetails', this._buildDetailHTML(doc, 'method', 'Methods', false));\n\n    return ice;\n  }\n\n  /**\n   * build variation of doc.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string} variation links html.\n   * @private\n   * @experimental\n   */\n  _buildVariationHTML(doc) {\n    const variationDocs = this._find({ memberof: doc.memberof, name: doc.name });\n    const html = [];\n    for (const variationDoc of variationDocs) {\n      if (variationDoc.variation === doc.variation) continue;\n\n      html.push(this._buildDocLinkHTML(variationDoc.longname, `(${ variationDoc.variation || 1 })`));\n    }\n\n    return html.join(', ');\n  }\n\n  /**\n   * build mixin extends html.\n   * @param {DocObject} doc - target class doc.\n   * @return {string} mixin extends html.\n   */\n  _buildMixinClassesHTML(doc) {\n    if (!doc.extends) return '';\n    if (doc.extends.length <= 1) return '';\n\n    const links = [];\n    for (const longname of doc.extends) {\n      links.push(this._buildDocLinkHTML(longname));\n    }\n\n    return `<div>${ links.join(', ') }</div>`;\n  }\n\n  /**\n   * build expression extends html.\n   * @param {DocObject} doc - target class doc.\n   * @return {string} expression extends html.\n   */\n  _buildExpressionExtendsHTML(doc) {\n    if (!doc.expressionExtends) return '';\n\n    const html = doc.expressionExtends.replace(/[A-Z_$][a-zA-Z0-9_$]*/g, v => {\n      return this._buildDocLinkHTML(v);\n    });\n\n    return `class ${ doc.name } extends ${ html }`;\n  }\n\n  /**\n   * build class ancestor extends chain.\n   * @param {DocObject} doc - target class doc.\n   * @returns {string} extends chain links html.\n   * @private\n   */\n  _buildExtendsChainHTML(doc) {\n    if (!doc._custom_extends_chains) return '';\n    if (doc.extends.length > 1) return '';\n\n    const links = [];\n    for (const longname of doc._custom_extends_chains) {\n      links.push(this._buildDocLinkHTML(longname));\n    }\n\n    links.push(doc.name);\n\n    return `<div>${ links.join('  ') }</div>`;\n  }\n\n  /**\n   * build in-direct subclass list.\n   * @param {DocObject} doc - target class doc.\n   * @returns {string} html of in-direct subclass links.\n   * @private\n   */\n  _buildIndirectSubclassHTML(doc) {\n    if (!doc._custom_indirect_subclasses) return '';\n\n    const links = [];\n    for (const longname of doc._custom_indirect_subclasses) {\n      links.push(this._buildDocLinkHTML(longname));\n    }\n\n    return `<div>${ links.join(', ') }</div>`;\n  }\n\n  /**\n   * build direct subclass list.\n   * @param {DocObject} doc - target class doc.\n   * @returns {string} html of direct subclass links.\n   * @private\n   */\n  _buildDirectSubclassHTML(doc) {\n    if (!doc._custom_direct_subclasses) return '';\n\n    const links = [];\n    for (const longname of doc._custom_direct_subclasses) {\n      links.push(this._buildDocLinkHTML(longname));\n    }\n\n    return `<div>${ links.join(', ') }</div>`;\n  }\n\n  /**\n   * build inherited method/member summary.\n   * @param {DocObject} doc - target class doc.\n   * @returns {string} html of inherited method/member from ancestor classes.\n   * @private\n   */\n  _buildInheritedSummaryHTML(doc) {\n    if (['class', 'interface'].indexOf(doc.kind) === -1) return '';\n\n    const longnames = [...(doc._custom_extends_chains || [])\n    // ...doc.implements || [],\n    // ...doc._custom_indirect_implements || [],\n    ];\n\n    const html = [];\n    for (const longname of longnames) {\n      const superDoc = this._find({ longname })[0];\n\n      if (!superDoc) continue;\n\n      const targetDocs = this._find({ memberof: longname, kind: ['member', 'method', 'get', 'set'] });\n\n      targetDocs.sort((a, b) => {\n        if (a.static !== b.static) return -(a.static - b.static);\n\n        let order = { get: 0, set: 0, member: 1, method: 2 };\n        if (order[a.kind] !== order[b.kind]) {\n          return order[a.kind] - order[b.kind];\n        }\n\n        order = { public: 0, protected: 1, private: 2 };\n        if (a.access !== b.access) return order[a.access] - order[b.access];\n\n        if (a.name !== b.name) return a.name < b.name ? -1 : 1;\n\n        order = { get: 0, set: 1, member: 2 };\n        return order[a.kind] - order[b.kind];\n      });\n\n      const title = `<span class=\"toggle closed\"></span> From ${ superDoc.kind } ${ this._buildDocLinkHTML(longname, superDoc.name) }`;\n      const result = this._buildSummaryDoc(targetDocs, '----------', false, superDoc.kind);\n      if (result) {\n        result.load('title', title, _iceCap2.default.MODE_WRITE);\n        html.push(result.html);\n      }\n    }\n\n    return html.join('\\n');\n  }\n}\nexports.default = ClassDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/SingleDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Single output builder class.\n * \"single\" means function, variable, typedef, external, etc...\n */\nclass SingleDocBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output.\n   * @param {function(html: string, filePath: string)} callback - is called with output.\n   */\n  exec(callback) {\n    const ice = this._buildLayoutDoc();\n    ice.autoClose = false;\n\n    const kinds = ['function', 'variable', 'typedef'];\n    for (const kind of kinds) {\n      const docs = this._find({ kind: kind });\n      if (!docs.length) continue;\n      const fileName = this._getOutputFileName(docs[0]);\n      const baseUrl = this._getBaseUrl(fileName);\n      let title = kind.replace(/^(\\w)/, c => c.toUpperCase());\n      title = this._getTitle(title);\n\n      ice.load('content', this._buildSingleDoc(kind), _iceCap2.default.MODE_WRITE);\n      ice.attr('baseUrl', 'href', baseUrl, _iceCap2.default.MODE_WRITE);\n      ice.text('title', title, _iceCap2.default.MODE_WRITE);\n      callback(ice.html, fileName);\n    }\n  }\n\n  /**\n   * build single output.\n   * @param {string} kind - target kind property.\n   * @returns {string} html of single output\n   * @private\n   */\n  _buildSingleDoc(kind) {\n    const title = kind.replace(/^(\\w)/, c => c.toUpperCase());\n    const ice = new _iceCap2.default(this._readTemplate('single.html'));\n    ice.text('title', title);\n    ice.load('summaries', this._buildSummaryHTML(null, kind, 'Summary'), 'append');\n    ice.load('details', this._buildDetailHTML(null, kind, ''));\n    return ice.html;\n  }\n}\nexports.default = SingleDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/FileDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * File output builder class.\n */\nclass FileDocBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output.\n   * @param {function(html: string, filePath: string)} callback - is called with each file.\n   */\n  exec(callback) {\n    const ice = this._buildLayoutDoc();\n\n    const docs = this._find({ kind: 'file' });\n    for (const doc of docs) {\n      const fileName = this._getOutputFileName(doc);\n      const baseUrl = this._getBaseUrl(fileName);\n      const title = this._getTitle(doc);\n      ice.load('content', this._buildFileDoc(doc), _iceCap2.default.MODE_WRITE);\n      ice.attr('baseUrl', 'href', baseUrl, _iceCap2.default.MODE_WRITE);\n      ice.text('title', title, _iceCap2.default.MODE_WRITE);\n      callback(ice.html, fileName);\n    }\n  }\n\n  /**\n   * build file output html.\n   * @param {DocObject} doc - target file doc object.\n   * @returns {string} html of file page.\n   * @private\n   */\n  _buildFileDoc(doc) {\n    const ice = new _iceCap2.default(this._readTemplate('file.html'));\n    ice.text('title', doc.longname);\n    ice.text('content', doc.content);\n    ice.drop('emptySourceCode', !!doc.content);\n    return ice.html;\n  }\n}\nexports.default = FileDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/SearchIndexBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Search index of identifier builder class.\n */\nclass SearchIndexBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output.\n   * @param {function(javascript: string, filePath: string)} callback - is called with output.\n   */\n  exec(callback) {\n    const searchIndex = [];\n    const docs = this._find({});\n\n    for (const doc of docs) {\n      let indexText;\n      let url;\n      let displayText;\n\n      if (doc.importPath) {\n        displayText = `<span>${ doc.name }</span> <span class=\"search-result-import-path\">${ doc.importPath }</span>`;\n        indexText = `${ doc.importPath }~${ doc.name }`.toLowerCase();\n        url = this._getURL(doc);\n      } else if (doc.kind === 'testDescribe' || doc.kind === 'testIt') {\n        displayText = doc.testFullDescription;\n        indexText = [...(doc.testTargets || []), ...(doc._custom_test_targets || [])].join(' ').toLowerCase();\n        const filePath = doc.longname.split('~')[0];\n        const fileDoc = this._find({ kind: 'testFile', longname: filePath })[0];\n        url = `${ this._getURL(fileDoc) }#lineNumber${ doc.lineNumber }`;\n      } else if (doc.kind === 'external') {\n        displayText = doc.longname;\n        indexText = displayText.toLowerCase();\n        url = doc.externalLink;\n      } else {\n        displayText = doc.longname;\n        indexText = displayText.toLowerCase();\n        url = this._getURL(doc);\n      }\n\n      let kind = doc.kind;\n      /* eslint-disable default-case */\n      switch (kind) {\n        case 'constructor':\n          kind = 'method';\n          break;\n        case 'get':\n        case 'set':\n          kind = 'member';\n          break;\n        case 'testDescribe':\n        case 'testIt':\n          kind = 'test';\n          break;\n      }\n\n      searchIndex.push([indexText, url, displayText, kind]);\n    }\n\n    searchIndex.sort((a, b) => {\n      if (a[2] === b[2]) {\n        return 0;\n      } else if (a[2] < b[2]) {\n        return -1;\n      } else {\n        return 1;\n      }\n    });\n\n    const javascript = `window.esdocSearchIndex = ${ JSON.stringify(searchIndex, null, 2) }`;\n\n    callback(javascript, 'script/search_index.js');\n  }\n}\nexports.default = SearchIndexBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/CoverageBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Coverage output builder class.\n */\nclass CoverageBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output.\n   * @param {function(coverage: CoverageObject, filePath: string)} callback - is called with coverage.\n   * @param {function(badge: string, filePath: string)} badgeCallback - is called with coverage badge.\n   */\n  exec(callback, badgeCallback) {\n    const docs = this._find({ kind: ['class', 'method', 'member', 'get', 'set', 'constructor', 'function', 'variable'] });\n    const expectCount = docs.length;\n    let actualCount = 0;\n    const files = {};\n\n    for (const doc of docs) {\n      const filePath = doc.longname.split('~')[0];\n      if (!files[filePath]) files[filePath] = { expectCount: 0, actualCount: 0, undocumentLines: [] };\n      files[filePath].expectCount++;\n\n      if (doc.undocument) {\n        files[filePath].undocumentLines.push(doc.lineNumber);\n      } else {\n        actualCount++;\n        files[filePath].actualCount++;\n      }\n    }\n\n    /* eslint-disable no-extra-parens */\n    const coveragePercent = expectCount === 0 ? 0 : Math.floor(10000 * actualCount / expectCount) / 100;\n\n    const coverage = {\n      coverage: `${ coveragePercent }%`,\n      expectCount: expectCount,\n      actualCount: actualCount,\n      files: files\n    };\n\n    callback(coverage, 'coverage.json');\n\n    // create badge\n    const ratio = Math.floor(100 * actualCount / expectCount);\n    let color;\n    if (ratio < 50) {\n      color = '#db654f';\n    } else if (ratio < 90) {\n      color = '#dab226';\n    } else {\n      color = '#4fc921';\n    }\n    let badge = this._readTemplate('image/badge.svg');\n    badge = badge.replace(/@ratio@/g, `${ ratio }%`);\n    badge = badge.replace(/@color@/g, color);\n    badgeCallback(badge, 'badge.svg');\n  }\n}\nexports.default = CoverageBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/ASTDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * AST Output Builder class.\n */\nclass ASTDocBuilder extends _DocBuilder2.default {\n  /**\n   * create instance.\n   * @param {Taffy} data - doc comment database.\n   * @param {AST[]} asts - all source code ASTs.\n   * @param {ESDocConfig} config - ESDoc config object.\n   */\n  constructor(data, asts, config) {\n    super(data, config);\n    this._asts = asts;\n  }\n\n  /**\n   * execute building output.\n   * @param {function(ast: string, filePath: string)} callback - is called each asts.\n   */\n  exec(callback) {\n    for (const ast of this._asts) {\n      const json = JSON.stringify(ast.ast, null, 2);\n      const filePath = `ast/${ ast.filePath }.json`;\n      callback(json, filePath);\n    }\n  }\n}\nexports.default = ASTDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/SourceDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nvar _util = require('./util.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Source output html builder class.\n */\nclass SourceDocBuilder extends _DocBuilder2.default {\n  /**\n   * create instance.\n   * @param {Taffy} data - doc object database.\n   * @param {ESDocConfig} config - use config to build output.\n   * @param {CoverageObject} coverage - use coverage to build output.\n   */\n  constructor(data, config, coverage) {\n    super(data, config);\n    this._coverage = coverage;\n  }\n\n  /**\n   * execute building output html.\n   * @param {function(html: string, filePath: string)} callback - is called with output html.\n   */\n  exec(callback) {\n    const ice = this._buildLayoutDoc();\n    const fileName = 'source.html';\n    const baseUrl = this._getBaseUrl(fileName);\n    const title = this._getTitle('Source');\n\n    ice.attr('baseUrl', 'href', baseUrl);\n    ice.load('content', this._buildSourceHTML());\n    ice.text('title', title, _iceCap2.default.MODE_WRITE);\n\n    callback(ice.html, fileName);\n  }\n\n  /**\n   * build source list output html.\n   * @returns {string} html of source list.\n   * @private\n   */\n  _buildSourceHTML() {\n    const ice = new _iceCap2.default(this._readTemplate('source.html'));\n    const docs = this._find({ kind: 'file' });\n    const config = this._config;\n    const useCoverage = this._config.coverage;\n    let coverage;\n    if (useCoverage) coverage = this._coverage.files;\n\n    ice.drop('coverageBadge', !useCoverage);\n    ice.attr('files', 'data-use-coverage', !!useCoverage);\n\n    if (useCoverage) {\n      const actual = this._coverage.actualCount;\n      const expect = this._coverage.expectCount;\n      const coverageCount = `${ actual }/${ expect }`;\n      ice.text('totalCoverageCount', coverageCount);\n    }\n\n    ice.loop('file', docs, (i, doc, ice) => {\n      const sourceDirPath = _path2.default.resolve(config.source);\n      const filePath = doc.longname;\n      const absFilePath = _path2.default.resolve(_path2.default.dirname(sourceDirPath), filePath);\n      const content = _fs2.default.readFileSync(absFilePath).toString();\n      const lines = content.split('\\n').length - 1;\n      const stat = _fs2.default.statSync(absFilePath);\n      const date = (0, _util.dateForUTC)(stat.ctime);\n      let coverageRatio;\n      let coverageCount;\n      let undocumentLines;\n      if (useCoverage && coverage[filePath]) {\n        const actual = coverage[filePath].actualCount;\n        const expect = coverage[filePath].expectCount;\n        coverageRatio = `${ Math.floor(100 * actual / expect) } %`;\n        coverageCount = `${ actual }/${ expect }`;\n        undocumentLines = coverage[filePath].undocumentLines.sort().join(',');\n      } else {\n        coverageRatio = '-';\n      }\n\n      const identifierDocs = this._find({\n        longname: { left: `${ doc.longname }~` },\n        kind: ['class', 'function', 'variable']\n      });\n      const identifiers = identifierDocs.map(doc => {\n        return this._buildDocLinkHTML(doc.longname);\n      });\n\n      if (undocumentLines) {\n        const url = this._getURL(doc);\n        const link = this._buildFileDocLinkHTML(doc).replace(/href=\".*\\.html\"/, `href=\"${ url }#errorLines=${ undocumentLines }\"`);\n        ice.load('filePath', link);\n      } else {\n        ice.load('filePath', this._buildFileDocLinkHTML(doc));\n      }\n      ice.text('coverage', coverageRatio);\n      ice.text('coverageCount', coverageCount);\n      ice.text('lines', lines);\n      ice.text('updated', date);\n      ice.text('size', `${ stat.size } byte`);\n      ice.load('identifier', identifiers.join('\\n') || '-');\n    });\n    return ice.html;\n  }\n}\nexports.default = SourceDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/TestDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Test file output html builder class.\n */\nclass TestDocBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output html.\n   * @param {function(html: string, filePath: string)} callback - is called with output html.\n   */\n  exec(callback) {\n    const testDescribeDoc = this._find({ kind: 'testDescribe' })[0];\n    if (!testDescribeDoc) return;\n\n    const ice = this._buildLayoutDoc();\n    const fileName = this._getOutputFileName(testDescribeDoc);\n    const baseUrl = this._getBaseUrl(fileName);\n    const title = this._getTitle('Test');\n\n    ice.load('content', this._buildTestDocHTML());\n    ice.attr('baseUrl', 'href', baseUrl);\n    ice.text('title', title);\n    callback(ice.html, fileName);\n  }\n\n  /**\n   * build whole test file output html.\n   * @returns {string} html of whole test file.\n   * @private\n   */\n  _buildTestDocHTML() {\n    const ice = new _iceCap2.default(this._readTemplate('test.html'));\n    const testDescribeHTML = this._buildTestDescribeDocHTML();\n    ice.load('tests', testDescribeHTML);\n    return ice.html;\n  }\n\n  /**\n   * build test describe list html.\n   * @param {number} [depth=0] - test depth.\n   * @param {string} [memberof] - target test.\n   * @returns {string} html of describe list.\n   * @private\n   */\n  _buildTestDescribeDocHTML(depth = 0, memberof = null) {\n    const cond = { kind: 'testDescribe', testDepth: depth };\n    if (memberof) cond.memberof = memberof;\n    const describeDocs = this._orderedFind('testId asec', cond);\n    let padding;\n    let html = '';\n\n    for (const describeDoc of describeDocs) {\n      const ice = new _iceCap2.default(this._readTemplate('testDescribe.html'));\n\n      const testCount = this._find({ kind: 'testIt', longname: { regex: new RegExp(`^${ describeDoc.longname }\\\\.`) } }).length;\n      padding = 10 * (depth + 1);\n      ice.attr('testDescribe', 'data-test-depth', depth);\n      /* eslint-disable no-loop-func */\n      ice.into('testDescribe', describeDoc, (describeDoc, ice) => {\n        const descriptionHTML = this._buildFileDocLinkHTML(describeDoc, describeDoc.description);\n\n        let testTargetsHTML = [];\n        for (const testTarget of describeDoc._custom_test_targets || []) {\n          testTargetsHTML.push(this._buildDocLinkHTML(testTarget[0], testTarget[1]));\n        }\n        testTargetsHTML = testTargetsHTML.join('\\n') || '-';\n\n        ice.load('testDescription', descriptionHTML);\n        ice.attr('testDescription', 'style', `padding-left: ${ padding }px`);\n        ice.load('testTarget', testTargetsHTML);\n        ice.text('testCount', testCount);\n      });\n\n      padding = 10 * (depth + 2);\n      const itDocs = this._orderedFind('testId asec', { kind: 'testIt', testDepth: depth + 1, memberof: describeDoc.longname });\n      /* eslint-disable no-loop-func */\n      ice.loop('testIt', itDocs, (i, itDoc, ice) => {\n        const descriptionHTML = this._buildFileDocLinkHTML(itDoc, itDoc.description);\n\n        let testTargetsHTML = [];\n        for (const testTarget of itDoc._custom_test_targets || []) {\n          testTargetsHTML.push(this._buildDocLinkHTML(testTarget[0], testTarget[1]));\n        }\n        testTargetsHTML = testTargetsHTML.join('\\n') || '-';\n\n        ice.attr('testIt', 'data-test-depth', depth + 1);\n        ice.load('testDescription', descriptionHTML);\n        ice.attr('testDescription', 'style', `padding-left: ${ padding }px`);\n        ice.load('testTarget', testTargetsHTML);\n      });\n\n      const innerDescribeHTML = this._buildTestDescribeDocHTML(depth + 1, describeDoc.longname);\n\n      html += `\\n${ ice.html }\\n${ innerDescribeHTML }`;\n    }\n\n    return html;\n  }\n}\nexports.default = TestDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/TestFileDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * File output html builder class.\n */\nclass TestFileDocBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output html.\n   * @param {function(html: string, filePath: string)} callback - is called with each output.\n   */\n  exec(callback) {\n    const ice = this._buildLayoutDoc();\n\n    const docs = this._find({ kind: 'testFile' });\n    for (const doc of docs) {\n      const fileName = this._getOutputFileName(doc);\n      const baseUrl = this._getBaseUrl(fileName);\n      const title = this._getTitle(doc);\n      ice.load('content', this._buildFileDoc(doc), _iceCap2.default.MODE_WRITE);\n      ice.attr('baseUrl', 'href', baseUrl, _iceCap2.default.MODE_WRITE);\n      ice.text('title', title, _iceCap2.default.MODE_WRITE);\n      callback(ice.html, fileName);\n    }\n  }\n\n  /**\n   * build file output html.\n   * @param {DocObject} doc - target file doc object.\n   * @returns {string} html of file output.\n   * @private\n   */\n  _buildFileDoc(doc) {\n    const ice = new _iceCap2.default(this._readTemplate('file.html'));\n    ice.text('title', doc.longname);\n    ice.text('content', doc.content);\n    ice.drop('emptySourceCode', !!doc.content);\n    return ice.html;\n  }\n}\nexports.default = TestFileDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/ManualDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _iceCap = require('ice-cap');\n\nvar _iceCap2 = _interopRequireDefault(_iceCap);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fsExtra = require('fs-extra');\n\nvar _fsExtra2 = _interopRequireDefault(_fsExtra);\n\nvar _cheerio = require('cheerio');\n\nvar _cheerio2 = _interopRequireDefault(_cheerio);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nvar _util = require('./util.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Manual Output Builder class.\n */\nclass ManualDocBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output.\n   * @param {function(html: string, filePath: string)} callback - is called each manual.\n   * @param {function(src: string, dest: string)} callbackForCopy - is called asset.\n   * @param {function(badge: string, filePath: string)} callbackForBadge - is called with coverage badge.\n   */\n  exec(callback, callbackForCopy, callbackForBadge) {\n    if (!this._config.manual) return;\n\n    const manualConfig = this._getManualConfig();\n    const ice = this._buildLayoutDoc();\n    ice.autoDrop = false;\n    ice.attr('rootContainer', 'class', ' manual-root');\n\n    {\n      const fileName = 'manual/index.html';\n      const baseUrl = this._getBaseUrl(fileName);\n      this._buildManualIndex(manualConfig);\n      ice.load('content', this._buildManualCardIndex(manualConfig), _iceCap2.default.MODE_WRITE);\n      ice.load('nav', this._buildManualNav(manualConfig), _iceCap2.default.MODE_WRITE);\n      ice.text('title', 'Manual', _iceCap2.default.MODE_WRITE);\n      ice.attr('baseUrl', 'href', baseUrl, _iceCap2.default.MODE_WRITE);\n      ice.attr('rootContainer', 'class', ' manual-index');\n      callback(ice.html, fileName);\n\n      if (this._config.manual.globalIndex) {\n        ice.attr('baseUrl', 'href', './', _iceCap2.default.MODE_WRITE);\n        callback(ice.html, 'index.html');\n      }\n\n      ice.attr('rootContainer', 'class', ' manual-index', _iceCap2.default.MODE_REMOVE);\n    }\n\n    for (const item of manualConfig) {\n      if (!item.paths) continue;\n      for (const filePath of item.paths) {\n        const fileName = this._getManualOutputFileName(item, filePath);\n        const baseUrl = this._getBaseUrl(fileName);\n        ice.load('content', this._buildManual(item, filePath), _iceCap2.default.MODE_WRITE);\n        ice.load('nav', this._buildManualNav(manualConfig), _iceCap2.default.MODE_WRITE);\n        ice.text('title', item.label, _iceCap2.default.MODE_WRITE);\n        ice.attr('baseUrl', 'href', baseUrl, _iceCap2.default.MODE_WRITE);\n        callback(ice.html, fileName);\n      }\n    }\n\n    if (this._config.manual.asset) {\n      callbackForCopy(this._config.manual.asset, 'manual/asset');\n    }\n\n    // badge\n    {\n      // const starCount = Math.min(Math.floor((manualConfig.length - 1) / 2), 5);\n      // const star = ''.repeat(starCount) + ''.repeat(5 - starCount);\n      const ratio = Math.floor(100 * (manualConfig.length - 1) / 10);\n\n      let color;\n      if (ratio < 50) {\n        color = '#db654f';\n      } else if (ratio < 90) {\n        color = '#dab226';\n      } else {\n        color = '#4fc921';\n      }\n\n      let badge = this._readTemplate('image/manual-badge.svg');\n      badge = badge.replace(/@value@/g, `${ ratio }%`);\n      badge = badge.replace(/@color@/g, color);\n      callbackForBadge(badge, 'manual-badge.svg');\n    }\n  }\n\n  /**\n   * get manual config based on ``config.manual``.\n   * @returns {ManualConfigItem[]} built manual config.\n   * @private\n   */\n  _getManualConfig() {\n    const m = this._config.manual;\n    const manualConfig = [];\n    if (m.overview) manualConfig.push({ label: 'Overview', paths: m.overview });\n    if (m.design) manualConfig.push({ label: 'Design', paths: m.design });\n    if (m.installation) manualConfig.push({ label: 'Installation', paths: m.installation });\n    if (m.tutorial) manualConfig.push({ label: 'Tutorial', paths: m.tutorial });\n    if (m.usage) manualConfig.push({ label: 'Usage', paths: m.usage });\n    if (m.configuration) manualConfig.push({ label: 'Configuration', paths: m.configuration });\n    if (m.advanced) manualConfig.push({ label: 'Advanced', paths: m.advanced });\n    if (m.example) manualConfig.push({ label: 'Example', paths: m.example });\n    manualConfig.push({ label: 'Reference', fileName: 'identifiers.html', references: true });\n    if (m.faq) manualConfig.push({ label: 'FAQ', paths: m.faq });\n    if (m.changelog) manualConfig.push({ label: 'Changelog', paths: m.changelog });\n    return manualConfig;\n  }\n\n  /**\n   * build manual navigation.\n   * @param {ManualConfigItem[]} manualConfig - target manual config.\n   * @return {IceCap} built navigation\n   * @private\n   */\n  _buildManualNav(manualConfig) {\n    const ice = this._buildManualIndex(manualConfig);\n    const $root = _cheerio2.default.load(ice.html).root();\n    $root.find('.github-markdown').removeClass('github-markdown');\n    return $root.html();\n  }\n\n  /**\n   * build manual.\n   * @param {ManualConfigItem} item - target manual config item.\n   * @param {string} filePath - target manual file path.\n   * @return {IceCap} built manual.\n   * @private\n   */\n  _buildManual(item, filePath) {\n    const html = this._convertMDToHTML(filePath);\n    const ice = new _iceCap2.default(this._readTemplate('manual.html'));\n    ice.text('title', item.label);\n    ice.load('content', html);\n\n    // convert relative src to base url relative src.\n    const $root = _cheerio2.default.load(ice.html).root();\n    $root.find('img').each((i, el) => {\n      const $el = (0, _cheerio2.default)(el);\n      const src = $el.attr('src');\n      if (!src) return;\n      if (src.match(/^http[s]?:/)) return;\n      if (src.charAt(0) === '/') return;\n      $el.attr('src', `./manual/${ src }`);\n    });\n    $root.find('a').each((i, el) => {\n      const $el = (0, _cheerio2.default)(el);\n      const href = $el.attr('href');\n      if (!href) return;\n      if (href.match(/^http[s]?:/)) return;\n      if (href.charAt(0) === '/') return;\n      if (href.charAt(0) === '#') return;\n      $el.attr('href', `./manual/${ href }`);\n    });\n\n    return $root.html();\n  }\n\n  /**\n   * built manual card style index.\n   * @param {ManualConfigItem[]} manualConfig - target manual config.\n   * @return {IceCap} built index.\n   * @private\n   */\n  _buildManualCardIndex(manualConfig) {\n    const cards = [];\n    for (const manualItem of manualConfig) {\n      if (manualItem.references) {\n        const filePath = _path2.default.resolve(this._config.destination, 'identifiers.html');\n        const html = _fsExtra2.default.readFileSync(filePath).toString();\n        const $ = _cheerio2.default.load(html);\n        const card = $('.content').html();\n        const identifiers = this._findAllIdentifiersKindGrouping();\n        const sectionCount = identifiers.class.length + identifiers.interface.length + identifiers.function.length + identifiers.typedef.length + identifiers.external.length;\n\n        cards.push({ label: 'References', link: 'identifiers.html', card: card, type: 'reference', sectionCount: sectionCount });\n        continue;\n      }\n\n      for (const filePath of manualItem.paths) {\n        const type = manualItem.label.toLowerCase();\n        const fileName = this._getManualOutputFileName(manualItem, filePath);\n        const html = this._buildManual(manualItem, filePath);\n        const $root = _cheerio2.default.load(html).root();\n        const h1Count = $root.find('h1').length;\n        const sectionCount = $root.find('h1,h2,h3,h4,h5').length;\n\n        $root.find('h1').each((i, el) => {\n          const $el = (0, _cheerio2.default)(el);\n          const label = $el.text();\n          const link = h1Count === 1 ? fileName : `${ fileName }#${ $el.attr('id') }`;\n          let card = `<h1>${ label }</h1>`;\n          const nextAll = $el.nextAll();\n\n          for (let i = 0; i < nextAll.length; i++) {\n            const next = nextAll.get(i);\n            const tagName = next.tagName.toLowerCase();\n            if (tagName === 'h1') return;\n            const $next = (0, _cheerio2.default)(next);\n            card += `<${ tagName }>${ $next.html() }</${ tagName }>`;\n          }\n\n          cards.push({ label, link, card, type, sectionCount });\n        });\n      }\n    }\n\n    const ice = new _iceCap2.default(this._readTemplate('manualCardIndex.html'));\n    ice.loop('cards', cards, (i, card, ice) => {\n      ice.text('label-inner', card.label);\n      ice.attr('label', 'class', `manual-color manual-color-${ card.type }`);\n\n      const sectionCount = Math.min(card.sectionCount / 5 + 1, 5);\n      ice.attr('label', 'data-section-count', ''.repeat(sectionCount));\n\n      ice.attr('link', 'href', card.link);\n      ice.load('card', card.card);\n    });\n\n    if (this._config.manual.index) {\n      const userIndex = this._convertMDToHTML(this._config.manual.index);\n      ice.load('manualUserIndex', userIndex);\n    } else {\n      ice.drop('manualUserIndex', true);\n    }\n\n    ice.drop('manualBadge', !this._config.manual.coverage);\n\n    return ice;\n  }\n\n  /**\n   * built manual index.\n   * @param {ManualConfigItem[]} manualConfig - target manual config.\n   * @return {IceCap} built index.\n   * @private\n   */\n  _buildManualIndex(manualConfig) {\n    const ice = new _iceCap2.default(this._readTemplate('manualIndex.html'));\n    const _manualConfig = manualConfig.filter(item => item.paths && item.paths.length || item.references);\n\n    ice.loop('manual', _manualConfig, (i, item, ice) => {\n      const toc = [];\n      if (item.references) {\n        const identifiers = this._findAllIdentifiersKindGrouping();\n        toc.push({ label: 'Reference', link: 'identifiers.html', indent: 'indent-h1' });\n        if (identifiers.class.length) toc.push({ label: 'Class', link: 'identifiers.html#class', indent: 'indent-h2' });\n        if (identifiers.interface.length) toc.push({ label: 'Interface', link: 'identifiers.html#interface', indent: 'indent-h2' });\n        if (identifiers.function.length) toc.push({ label: 'Function', link: 'identifiers.html#function', indent: 'indent-h2' });\n        if (identifiers.variable.length) toc.push({ label: 'Variable', link: 'identifiers.html#variable', indent: 'indent-h2' });\n        if (identifiers.typedef.length) toc.push({ label: 'Typedef', link: 'identifiers.html#typedef', indent: 'indent-h2' });\n        if (identifiers.external.length) toc.push({ label: 'External', link: 'identifiers.html#external', indent: 'indent-h2' });\n\n        toc[0].sectionCount = identifiers.class.length + identifiers.interface.length + identifiers.function.length + identifiers.typedef.length + identifiers.external.length;\n      } else {\n        for (const filePath of item.paths) {\n          const fileName = this._getManualOutputFileName(item, filePath);\n          const html = this._convertMDToHTML(filePath);\n          const $root = _cheerio2.default.load(html).root();\n          const h1Count = $root.find('h1').length;\n          const sectionCount = $root.find('h1,h2,h3,h4,h5').length;\n\n          $root.find('h1,h2,h3,h4,h5').each((i, el) => {\n            const $el = (0, _cheerio2.default)(el);\n            const label = $el.text();\n            const indent = `indent-${ el.tagName.toLowerCase() }`;\n\n            let link = `${ fileName }#${ $el.attr('id') }`;\n            if (el.tagName.toLowerCase() === 'h1' && h1Count === 1) link = fileName;\n\n            toc.push({ label, link, indent, sectionCount });\n          });\n        }\n      }\n\n      ice.attr('manual', 'data-toc-name', item.label.toLowerCase());\n      ice.loop('manualNav', toc, (i, tocItem, ice) => {\n        if (tocItem.indent === 'indent-h1') {\n          ice.attr('manualNav', 'class', `${ tocItem.indent } manual-color manual-color-${ item.label.toLowerCase() }`);\n          const sectionCount = Math.min(tocItem.sectionCount / 5 + 1, 5);\n          ice.attr('manualNav', 'data-section-count', ''.repeat(sectionCount));\n        } else {\n          ice.attr('manualNav', 'class', tocItem.indent);\n        }\n\n        ice.attr('manualNav', 'data-link', tocItem.link.split('#')[0]);\n        ice.text('link', tocItem.label);\n        ice.attr('link', 'href', tocItem.link);\n      });\n    });\n\n    return ice;\n  }\n\n  /**\n   * get manual file name.\n   * @param {ManualConfigItem} item - target manual config item.\n   * @param {string} filePath - target manual markdown file path.\n   * @returns {string} file name.\n   * @private\n   */\n  _getManualOutputFileName(item, filePath) {\n    if (item.fileName) return item.fileName;\n\n    const fileName = _path2.default.parse(filePath).name;\n    return `manual/${ item.label.toLowerCase() }/${ fileName }.html`;\n  }\n\n  /**\n   * convert markdown to html.\n   * if markdown has only one ``h1`` and it's text is ``item.label``, remove the ``h1``.\n   * because duplication ``h1`` in output html.\n   * @param {string} filePath - target.\n   * @returns {string} converted html.\n   * @private\n   */\n  _convertMDToHTML(filePath) {\n    const content = _fsExtra2.default.readFileSync(filePath).toString();\n    const html = (0, _util.markdown)(content);\n    const $root = _cheerio2.default.load(html).root();\n    return $root.html();\n  }\n}\nexports.default = ManualDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Publisher/Builder/LintDocBuilder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._results = undefined;\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fsExtra = require('fs-extra');\n\nvar _fsExtra2 = _interopRequireDefault(_fsExtra);\n\nvar _DocBuilder = require('./DocBuilder.js');\n\nvar _DocBuilder2 = _interopRequireDefault(_DocBuilder);\n\nvar _ASTNodeContainer = require('../../Util/ASTNodeContainer.js');\n\nvar _ASTNodeContainer2 = _interopRequireDefault(_ASTNodeContainer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @ignore */\nconst _results = exports._results = [];\n\n/**\n * Lint Output Builder class.\n */\nclass LintDocBuilder extends _DocBuilder2.default {\n  /**\n   * execute building output.\n   */\n  exec() {\n    const results = [];\n    const docs = this._find({ kind: ['method', 'function'] });\n    for (const doc of docs) {\n      if (doc.undocument) continue;\n\n      const node = _ASTNodeContainer2.default.getNode(doc.__docId__);\n      const codeParams = this._getParamsFromNode(node);\n      const docParams = this._getParamsFromDoc(doc);\n      if (this._match(codeParams, docParams)) continue;\n\n      results.push({ node, doc, codeParams, docParams });\n    }\n\n    _results.push(...results);\n\n    this._showResult(results);\n  }\n\n  /**\n   * get variable names of method argument.\n   * @param {ASTNode} node - target node.\n   * @returns {string[]} variable names.\n   * @private\n   */\n  _getParamsFromNode(node) {\n    let params;\n    switch (node.type) {\n      case 'FunctionExpression':\n      case 'FunctionDeclaration':\n        params = node.params || [];\n        break;\n      case 'ClassMethod':\n        params = node.params || [];\n        break;\n      case 'ArrowFunctionExpression':\n        params = node.params || [];\n        break;\n      default:\n        throw new Error(`unknown node type. type = ${ node.type }`);\n    }\n\n    const result = [];\n    for (const param of params) {\n      switch (param.type) {\n        case 'Identifier':\n          result.push(param.name);\n          break;\n        case 'AssignmentPattern':\n          if (param.left.type === 'Identifier') {\n            result.push(param.left.name);\n          } else if (param.left.type === 'ObjectPattern') {\n            result.push('*');\n          }\n          break;\n        case 'RestElement':\n          result.push(param.argument.name);\n          break;\n        case 'ObjectPattern':\n          result.push('*');\n          break;\n        case 'ArrayPattern':\n          result.push('*');\n          break;\n        default:\n          throw new Error(`unknown param type: ${ param.type }`);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * get variable names of method argument.\n   * @param {DocObject} doc - target doc object.\n   * @returns {string[]} variable names.\n   * @private\n   */\n  _getParamsFromDoc(doc) {\n    const params = doc.params || [];\n    return params.map(v => v.name).filter(v => !v.includes('.')).filter(v => !v.includes('['));\n  }\n\n  _match(codeParams, docParams) {\n    if (codeParams.length !== docParams.length) return false;\n\n    for (let i = 0; i < codeParams.length; i++) {\n      if (codeParams[i] === '*') {\n        // nothing\n      } else if (codeParams[i] !== docParams[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * show invalid lint code.\n   * @param {Object[]} results - target results.\n   * @param {DocObject} results[].doc\n   * @param {ASTNode} results[].node\n   * @param {string[]} results[].codeParams\n   * @param {string[]} results[].docParams\n   * @private\n   */\n  _showResult(results) {\n    const sourceDir = _path2.default.dirname(_path2.default.resolve(this._config.source));\n    for (const result of results) {\n      const doc = result.doc;\n      const node = result.node;\n      const filePath = doc.longname.split('~')[0];\n      const name = doc.longname.split('~')[1];\n      const absFilePath = _path2.default.resolve(sourceDir, filePath);\n      const comment = node.leadingComments[node.leadingComments.length - 1];\n      const startLineNumber = comment.loc.start.line;\n      const endLineNumber = node.loc.start.line;\n      const lines = _fsExtra2.default.readFileSync(absFilePath).toString().split('\\n');\n      const targetLines = [];\n\n      for (let i = startLineNumber - 1; i < endLineNumber; i++) {\n        targetLines.push(`${ i }| ${ lines[i] }`);\n      }\n\n      console.log(`\u001b[33mwarning: signature mismatch: ${ name } ${ filePath }#${ startLineNumber }\u001b[32m`);\n      console.log(targetLines.join('\\n'));\n      console.log('\u001b[0m');\n    }\n  }\n}\nexports.default = LintDocBuilder;","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/BuiltinExternal/ECMAScriptExternal.js":"// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n\n// Value properties\n/**\n * @external {Infinity} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity\n */\n\n/**\n * @external {NaN} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN\n */\n\n/**\n * @external {undefined} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined\n */\n\n/**\n * @external {null} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null\n */\n\n// Fundamental objects\n/**\n * @external {Object} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n */\n/**\n * @external {object} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n */\n\n/**\n * @external {Function} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\n */\n/**\n * @external {function} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\n */\n\n/**\n * @external {Boolean} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean\n */\n/**\n * @external {boolean} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean\n */\n\n/**\n * @external {Symbol} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\n */\n\n/**\n * @external {Error} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n */\n\n/**\n * @external {EvalError} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError\n */\n\n/**\n * @external {InternalError} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError\n */\n\n/**\n * @external {RangeError} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\n */\n\n/**\n * @external {ReferenceError} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError\n */\n\n/**\n * @external {SyntaxError} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError\n */\n\n/**\n * @external {TypeError} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\n */\n\n/**\n * @external {URIError} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError\n */\n\n// Numbers and dates\n/**\n * @external {Number} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number\n */\n/**\n * @external {number} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number\n */\n\n/**\n * @external {Date} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n */\n\n// Text processing\n/**\n * @external {String} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n */\n/**\n * @external {string} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n */\n\n/**\n * @external {RegExp} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n */\n\n// Indexed collections\n/**\n * @external {Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n */\n\n/**\n * @external {Int8Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array\n */\n/**\n * @external {Uint8Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n */\n\n/**\n * @external {Uint8ClampedArray} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray\n */\n\n/**\n * @external {Int16Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array\n */\n\n/**\n * @external {Uint16Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array\n */\n\n/**\n * @external {Int32Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array\n */\n\n/**\n * @external {Uint32Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\n */\n\n/**\n * @external {Float32Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array\n */\n\n/**\n * @external {Float64Array} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array\n */\n\n// Keyed collections\n/**\n * @external {Map} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\n */\n\n/**\n * @external {Set} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n */\n\n/**\n * @external {WeakMap} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\n */\n\n/**\n * @external {WeakSet} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\n */\n\n// Structured data\n/**\n * @external {ArrayBuffer} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\n */\n\n/**\n * @external {DataView} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\n */\n\n/**\n * @external {JSON} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON\n */\n\n// Control abstraction objects\n/**\n * @external {Promise} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n */\n\n/**\n * @external {Generator} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\n */\n\n/**\n * @external {GeneratorFunction} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction\n */\n\n// Reflection\n/**\n * @external {Reflect} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\n */\n\n/**\n * @external {Proxy} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n */\n\"use strict\";","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/BuiltinExternal/WebAPIExternal.js":"// https://developer.mozilla.org/en-US/docs/Web/API\n\n/**\n * @external {CanvasRenderingContext2D} https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n */\n\n/**\n * @external {DocumentFragment} https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment\n */\n\n/**\n * @external {Element} https://developer.mozilla.org/en-US/docs/Web/API/Element\n */\n\n/**\n * @external {Event} https://developer.mozilla.org/en-US/docs/Web/API/Event\n */\n\n/**\n * @external {Node} https://developer.mozilla.org/en-US/docs/Web/API/Node\n */\n\n/**\n * @external {NodeList} https://developer.mozilla.org/en-US/docs/Web/API/NodeList\n */\n\n/**\n * @external {XMLHttpRequest} https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest\n */\n\n/**\n* @external {AudioContext} https://developer.mozilla.org/en/docs/Web/API/AudioContext\n*/\n\"use strict\";","/home/travis/build/npmtest/node-npmtest-esdoc/node_modules/esdoc/out/src/Typedef/typedef.js":"/**\n * ESDoc config object.\n * @typedef {Object} ESDocConfig\n * @property {!string} source - directory path of javascript source code.\n * @property {!string} destination - directory path of output.\n * @property {string} [title]\n * @property {string[]} [includes=[\"\\\\.(js|es6)$\"]]\n * @property {string[]} [excludes=[\"\\\\.config\\\\.(js|es6)$\"]]\n * @property {string[]} [access=[\"public\", \"protected\"]]\n * @property {boolean} [autoPrivate=true]\n * @property {boolean} [builtinExternal=true]\n * @property {boolean} [unexportIdentifier=false]\n * @property {boolean} [undocumentIdentifier=true]\n * @property {boolean} [coverage=true]\n * @property {boolean} [debug=false]\n * @property {string} [index=\"./README.md\"]\n * @property {string} [package=\"./package.json\"]\n * @property {string[]} [styles=[]]\n * @property {string[]} [scripts=[]]\n * @property {{type: string, source: string, includes: string[], excludes: string[]}} test\n * @property {Object} [manual]\n * @property {boolean} manual.globalIndex\n * @property {string} manual.asset\n * @property {string} manual.index\n * @property {string[]} manual.overview\n * @property {string[]} manual.design\n * @property {string[]} manual.installation\n * @property {string[]} manual.usage\n * @property {string[]} manual.tutorial\n * @property {string[]} manual.configuration\n * @property {string[]} manual.example\n * @property {string[]} manual.advanced\n * @property {string[]} manual.faq\n * @property {string[]} manual.changelog\n * @property {Object} [experimentalProposal]\n * @property {boolean} experimentalProposal.classProperties\n * @property {boolean} experimentalProposal.objectRestSpread\n * @property {boolean} experimentalProposal.doExpressions\n * @property {boolean} experimentalProposal.functionBind\n * @property {boolean} experimentalProposal.functionSent\n * @property {boolean} experimentalProposal.asyncGenerators\n * @property {boolean} experimentalProposal.decorators\n * @property {boolean} experimentalProposal.exportExtensions\n * @property {boolean} experimentalProposal.dynamicImport\n * @see https://esdoc.org/config.html\n */\n\n/**\n * doc comment tag.\n * @typedef {Object} Tag\n * @property {string} tagName\n * @property {*} tagValue\n */\n\n/**\n * Parsed doc comment.\n * @typedef {Object} DocObject\n */\n\n/**\n * @typedef {Object} AST\n * @property {Object} body\n * @property {Object[]} leadingComments\n * @see https://github.com/estree/estree\n */\n\n/**\n * @typedef {Object} ASTNode\n * @see https://github.com/estree/estree\n * @property {string} type\n * @property {Object} [superClass]\n * @property {Object[]} [leadingComments]\n * @property {Object[]} [trailingComments]\n * @property {Object[]} [body]\n * @property {ASTNode} [parent] - this is customize by ESDoc\n */\n\n/**\n * @typedef {Object} NPMPackageObject\n * @see https://docs.npmjs.com/files/package.json\n */\n\n/**\n * @typedef {Object} Taffy\n * @see http://www.taffydb.com/\n */\n\n/**\n * @typedef {Object} IceCap\n * @see https://github.com/h13i32maru/ice-cap\n */\n\n/**\n * @typedef {Object} CoverageObject\n * @property {string} coverage - ratio.\n * @property {number} expectCount - all identifier count.\n * @property {number} actualCount - documented identifier count.\n * @property {Object<string, Object>} files - file name and coverage.\n */\n\n/**\n * ESDocCLI uses argv\n * @typedef {Object} ESDocCLIArgv\n * @property {boolean} [h] - for help\n * @property {boolean} [help] - for help\n * @property {boolean} [v] - for version\n * @property {boolean} [version] - for version\n * @property {string} [c] - for config file path\n * @property {string[]} [_] - for source directory path\n */\n\n/**\n * @typedef {Object} DocTypedef\n */\n\n/**\n * @typedef {Object} PackageTypedef\n * @property {Object} repository\n * @property {string} repository.url\n */\n\n/**\n * @typedef {Object} ParsedParam\n * @property {boolean} [nullable]\n * @property {string[]} types\n * @property {boolean} [spread]\n * @property {boolean} [optional]\n * @property {string} [defaultValue]\n * @property {*} [defaultRaw]\n * @property {string} [name]\n * @property {string} [description]\n */\n\n/**\n * @todo remove this typedef.\n * @typedef {Object} IceCapInstanceTypedef\n * @property {function} loop\n * @property {function} attr\n * @property {function} text\n * @property {function} load\n * @property {function} into\n * @property {function} drop\n * @property {string} html\n */\n\n/**\n * @todo remove this typedef.\n * @typedef {Object} TaffyCursor\n * @property {function} each\n */\n\n/**\n * @typedef {Object} ManualConfigItem\n * @property {string} label\n * @property {string[]} paths\n * @property {string} [fileName]\n * @property {string} [reference]\n */\n\"use strict\";"}